---
title: Import Functions
description: Learn how to import functions from other plugins written in different languages and use them in your own.
icon: lucide:arrow-down
---

To use functions from another plugin in your Go plugin, you need to generate language-specific header files. These headers provide the necessary wrappers to call functions exported by other plugins. This guide explains how to generate these headers and how to use them in your Go plugin.

## **Generating Header Files**

Plugify provides a unified generator tool to automatically generate header files for importing functions from other plugins. These headers include wrapper functions that handle the function calls and parameter passing.

### **Steps to Generate Bindings**

::steps{level=4}
#### **Using the Online Generator**:
Visit [plugify-gen tool](https://gen.plugify.net/) to generate bindings through a user-friendly web interface. Simply upload your plugin manifest file (`.pplugin`) and select Go as the target language to generate the corresponding Go module.

#### **Using the Command-Line Tool**:
You can also download and use the generator tool locally from the [plugify-gen repository](https://github.com/untrustedmodders/plugify-gen/).

**Example usage**:
```bash
plugify-gen -manifest ./plugins/MyPlugin/MyPlugin.pplugin -output ./output/ -lang go
```

#### **Integrate the Generated Module**:
- The tool will generate a module folder (e.g., `plugin_from_another_language/`) in the specified output directory.
- Copy the entire generated module folder to your project directory.
- The module can be imported as a local Go package in your plugin.
::

## **Project Integration**

After generating the module, integrate it into your Go project:

::steps
### **Copy Module to Project**
Copy the generated module folder to your project directory:
```bash
cp -r ./output/plugin_from_another_language ./my_plugin/
```

### **Import the Module**
Import the generated package in your Go files:
```go
import (
    "my_plugin/plugin_from_another_language"
)
```

### **Update go.mod (if needed)**
If using Go modules, ensure the local module is accessible:
```go
module my_plugin

go 1.21

replace my_plugin/plugin_from_another_language => ./plugin_from_another_language
```
::

## **Using Generated Wrapper Functions**

The generated module contains wrapper functions that allow you to call functions from the other plugin. These wrappers handle the function address lookup and parameter passing.

### **Example Generated Header**
Here’s an example of a generated header file for a plugin named `plugin_from_another_language`:

::code-group
```go [plugin_from_another_language.go]
package plugin_from_another_language

// Generated from plugin_from_another_language.pplugin by https://github.com/untrustedmodders/plugify-gen

// #include "plugin_from_another_language.h"
import "C"
import "unsafe"

func ParamCallback(a int32, b float32, c float64, d Vector4, e []int64, f int8, g string, h uint16, k int16) {
    C_a := C.int32_t(a)
    C_b := C.float(b)
    C_c := C.double(c)
    C_d := *(*C.Vector4)(unsafe.Pointer(&d))
    var A_e unsafe.Pointer
    S_e := len(e)
    if S_e > 0 {
        A_e = unsafe.Pointer(&e[0])
    } else {
        A_e = nil
    }
    C_e := C.Plugify_ConstructVector(A_e, C.ptrdiff_t(S_e), C.INT64)
    C_f := C.char(f)
    C_g := C.Plugify_ConstructString(g)
    C_h := C.uint16_t(h)
    C_k := C.int16_t(k)

    C.ParamCallback(C_a, C_b, C_c, &C_d, &C_e, C_f, &C_g, C_h, C_k)

    C.Plugify_DestroyVector(&C_e, C.INT64)
    C.Plugify_DestroyString(&C_g)
}
```
::

::code-group
```c [plugin_from_another_language.h]
extern void (*__plugin_from_another_language_ParamCallback)(int32_t, float, double, Vector4*, Vector*, char, String*, uint16_t, int16_t);

static void ParamCallback(int32_t a, float b, double c, Vector4* d, Vector* e, char f, String* g, uint16_t h, int16_t k) {
	__plugin_from_another_language_ParamCallback(a, b, c, d, e, f, g, h, k);
}
```
::

### **How It Works**
- The wrapper function (`ParamCallback`) handles parameter marshaling and cleanup.
- The `____plugin_from_another_language_ParamCallback` delegate is set by the language module during plugin load.
- The wrapper function ensures that Go types are correctly converted to C types and vice versa.

## **Example: Using the Generated Header**

Here’s how you can use the generated header in your Go plugin:

::code-group
```go [plugin.go]
package main

import (
    "plugin_from_another_language"
    "fmt"
)

func main() {
    // Call the exported function from the other plugin
    plugin_from_another_language.ParamCallback(
        42,                // int32 a
        3.14,              // float32 b
        2.718,             // float64 c
        plugin_from_another_language.Vector4{1, 2, 3, 4}, // Vector4 d
        []int64{100, 200}, // []int64 e
        'x',               // int8 f
        "Hello, Plugify!", // string g
        123,               // uint16 h
        10,                // int16 k
    )
}
```
::

## **When is Header Generation Necessary?**

Header generation is essential when importing functions from plugins written in statically-typed languages like C++ or Go. Without these headers, the compiler cannot reference the exported functions. For dynamically-typed languages like Python, header generation is not necessary because method binding happens at runtime.

## **Best Practices**

1. **Use the Generator Tool**: Always use the Plugify generator tool (online or command-line) to generate headers for imported functions.
2. **Include Generated Headers**: Include the generated headers in your plugin source files to access the exported functions.
3. **Test Thoroughly**: Test the imported functions to ensure they work as expected.
4. **Document Dependencies**: Clearly document the plugins and functions your plugin depends on.

## **Conclusion**

Importing functions from another plugin in Go is straightforward when you use the Plugify generator tool to generate the necessary headers. These headers provide wrapper functions that handle function address lookup and parameter passing, making it easy to integrate functionality from other plugins. By following the steps and best practices outlined in this guide, you can create robust and interoperable plugins in the Plugify ecosystem.