---
title: Import Functions
description: Learn how to import functions from other plugins written in different languages and use them in your own.
icon: lucide:arrow-down
---

To use functions from another plugin in your D plugin, you need to generate language-specific header files. These headers provide the necessary wrappers to call functions exported by other plugins. This guide explains how to generate these headers and how to use them in your Go plugin.

## **Generating Header Files**

Plugify provides a unified generator tool to automatically generate header files for importing functions from other plugins. These headers include wrapper functions that handle the function calls and parameter passing.

### **Steps to Generate Bindings**

::steps{level=4}
#### **Using the Online Generator**:
Visit [plugify-gen tool](https://gen.plugify.net/) to generate bindings through a user-friendly web interface. Simply upload your plugin manifest file (`.pplugin`) and select D as the target language to generate the corresponding D module.

#### **Using the Command-Line Tool**:
You can also download and use the generator tool locally from the [plugify-gen repository](https://github.com/untrustedmodders/plugify-gen/).

**Example usage**:
```bash
plugify-gen -manifest ./plugins/MyPlugin/MyPlugin.pplugin -output ./output/ -lang d
```

#### **Integrate the Generated Module**:
- The tool will generate a module folder (e.g., `plugin_from_another_language/`) in the specified output directory.
- Copy the entire generated module folder to your project's source directory.
- Add the module directory to your D compiler's import paths.
::

## **Project Integration**

After generating the module, integrate it into your D project:

::steps
### **Copy Module to Project**
Copy the generated module folder to your project's source directory:
```bash
cp -r ./output/plugin_from_another_language ./my_plugin/source/
```

### **Update dub.json**
Add the module to your import paths in `dub.json`:
```json
{
    "name": "my_plugin",
    "sourcePaths": ["source", "source/plugin_from_another_language"],
    "importPaths": ["source", "source/plugin_from_another_language"]
}
```

### **Import in Source Files**
Import the generated module in your D files:
```d
import plugin_from_another_language;
```
::

## **Using Generated Wrapper Functions**

The generated module contains wrapper functions that allow you to call functions from the other plugin. These wrappers handle the function address lookup and parameter passing.

### **Example Generated Header**
Here’s an example of a generated header file for a plugin named `plugin_from_another_language`:

::code-group
```cpp [plugin_from_another_language.d]
// Generated from plugin_from_another_language.pplugin by https://github.com/untrustedmodders/plugify-gen

alias ParamCallbackFn = void function(int, float, double, Vector4*, PlgVector*, char, PlgString*, ushort, short);

void ParamCallback(int a, float b, double c, Vector4 d, long[] e, char f, string g, ushort h, short k) {
    static ParamCallbackFn __func = Plugify_GetMethodPtr("cross_call_master.ParamCallback");
    
    PlgVector _e(e);
    PlgString _g(g);

    __func(a, b, c, &d, &_e, f, &_g, h, k);
}
```
::

### **How It Works**
- The wrapper function (`ParamCallback`) handles parameter marshaling and cleanup.
- The function address is stored in a static variable (`__func`) to avoid repeated lookups.
- The wrapper function ensures that D types are correctly converted to C types and vice versa.

## **Example: Using the Generated Header**

Here’s how you can use the generated header in your Go plugin:

::code-group
```cpp [plugin.d]
import std.stdio;
import plugin_from_another_language;

void main() {
    // Call the exported function from the other plugin
    plugin_from_another_language.ParamCallback(
        42,                  // int a
        3.14f,               // float b
        2.718,               // double c
        Vector4(1, 2, 3, 4), // Vector4 d
        [100L, 200L],        // long[] e
        cast(char) 'x',      // char f
        "Hello, Plugify!",   // string g
        cast(uint) 123,      // ushort h
        cast(short) 10       // short k
    );
}
```
::

## **When is Header Generation Necessary?**

Header generation is essential when importing functions from plugins written in statically-typed languages like C++ or Go. Without these headers, the compiler cannot reference the exported functions. For dynamically-typed languages like Python, header generation is not necessary because method binding happens at runtime.

## **Best Practices**

1. **Use the Generator Tool**: Always use the Plugify generator tool (online or command-line) to generate headers for imported functions.
2. **Include Generated Headers**: Include the generated headers in your plugin source files to access the exported functions.
3. **Test Thoroughly**: Test the imported functions to ensure they work as expected.
4. **Document Dependencies**: Clearly document the plugins and functions your plugin depends on.

## **Conclusion**

Importing functions from another plugin in D is straightforward when you use the Plugify generator tool to generate the necessary headers. These headers provide wrapper functions that handle function address lookup and parameter passing, making it easy to integrate functionality from other plugins. By following the steps and best practices outlined in this guide, you can create robust and interoperable plugins in the Plugify ecosystem.