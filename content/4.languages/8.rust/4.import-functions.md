---
title: Import Functions
description: Learn how to import functions from other plugins written in different languages and use them in your own.
icon: lucide:arrow-down
---

To use functions from another plugin in your Rust plugin, you need to generate language-specific bindings. These bindings provide the necessary wrappers to call functions exported by other plugins. This guide explains how to generate these bindings and how to use them in your Rust plugin.

## **Generating Rust Bindings**

Plugify provides a unified generator tool to automatically generate Rust code for importing functions from other plugins. These bindings include wrapper functions that handle the function calls and parameter passing.

### **Steps to Generate Rust Bindings**

::steps{level=4}
#### **Using the Online Generator**:
Visit [plugify-gen tool](https://gen.plugify.net/) to generate bindings through a user-friendly web interface. Simply upload your plugin manifest file (`.pplugin`) and select Rust as the target language to generate the corresponding `.rs` file.

#### **Using the Command-Line Tool**:
You can also download and use the generator tool locally from the [plugify-gen repository](https://github.com/untrustedmodders/plugify-gen/).

**Example usage**:
```bash
plugify-gen -manifest ./plugins/plugin_from_another_language/plugin_from_another_language.pplugin -output ./output/ -lang rust
```

#### **Include the Generated Module**:
- The tool will generate a Rust file (e.g., `plugin_from_another_language.rs`) in the specified output folder.
- Include this module in your Rust plugin source files to use the exported functions.
::

## **Using Generated Wrapper Functions**

The generated Rust file contains wrapper functions that allow you to call functions from the other plugin. These wrappers handle the function address lookup and parameter passing.

### **Example Generated Bindings**

Here's an example of a generated Rust binding file for a plugin named `plugin_from_another_language`:

::code-group
```rust [plugin_from_another_language.rs]
// Generated from plugin_from_another_language.pplugin by https://github.com/untrustedmodders/plugify-gen

use plugify::*;

pub mod plugin_from_another_language {
    use super::*;

    pub fn param_callback(
        a: i32,
        b: f32,
        c: f64,
        d: &Vector4,
        e: &PlgVector<i64>,
        f: i8,
        g: &PlgString,
        h: u16,
        k: i16
    ) {
        unsafe {
            static FUNC: OnceLock<unsafe extern "C" fn(i32, f32, f64, &Vector4, &PlgVector<i64>, i8, &PlgString, u16, i16)> = OnceLock::new();
            let __func = FUNC.get_or_init(|| {
                let name = "plugin_from_another_language.ParamCallback";
                let ptr = get_method_ptr(name.as_ptr(), name.len());
                std::mem::transmute(ptr)
            });
            __func(a, b, c, d, e, f, g, h, k)
        }
    }
}
```
::

### **How It Works**
- The wrapper function (`param_callback`) retrieves the address of the exported function using the Plugify API.
- The function address is stored in a static variable (`FUNC`) to avoid repeated lookups.
- The wrapper function directly passes the parameters to the exported function.

## **Example: Using the Generated Bindings**

Here's how you can use the generated bindings in your Rust plugin:

::code-group
```rust [src/lib.rs]
mod plugin_from_another_language;

use plugify::*;
use plugin_from_another_language::*;

fn on_plugin_start() {
    // Call the exported function from the other plugin
    let data = PlgVector::from(vec![100i64, 200i64]);
    let message = PlgString::from("Hello, Plugify!");
    let vec4 = Vector4::new(1.0, 2.0, 3.0, 4.0);

    plugin_from_another_language::param_callback(
        42,          // i32 a
        3.14,        // f32 b
        2.718,       // f64 c
        &vec4,       // &Vector4 d
        &data,       // &PlgVector<i64> e
        'x' as i8,   // i8 f
        &message,    // &PlgString g
        'âœ“' as u16,  // u16 h
        10           // i16 k
    );
}

register_plugin!(
    start: on_plugin_start
);
```
::

## **Working with PlgTypes**

Plugify uses special types for cross-language compatibility:

### **PlgString**

```rust
use plugify::PlgString;

// Create from Rust string
let msg = PlgString::from("Hello");

// Create from String
let msg = PlgString::from(String::from("Hello"));

// Convert to Rust &str
let s: &str = msg.as_str();

// Convert to String
let string: String = msg.to_string();
```

### **PlgVector\<T\>**

```rust
use plugify::PlgVector;

// Create from Vec
let numbers = PlgVector::from(vec![1, 2, 3, 4, 5]);

// Create empty
let mut data: PlgVector<i32> = PlgVector::new();
data.push(42);

// Access elements
let first = data[0];

// Iterate
for num in &numbers {
    println!("{}", num);
}

// Convert to Vec
let vec: Vec<i32> = numbers.into();
```

### **PlgVariant**

```rust
use plugify::PlgVariant;

// Create from different types
let var1 = PlgVariant::from(PlgAny::Int32(42));
let var2 = PlgVariant::from(PlgAny::Float(3.14);
let var3 = PlgVariant::from(PlgAny::String("text"));

// Extract value
match var1.get() {
    PlgAny::Int32(num) => println!("Number: {}", num),
    _ => println!("NA"),
}
```

## **When is Binding Generation Necessary?**

Binding generation is essential when importing functions from plugins written in other languages. Without these bindings, you cannot safely call the exported functions. The generator ensures type safety and proper ABI compatibility.

## **Best Practices**

1. **Use the Generator Tool**: Always use the Plugify generator tool (online or command-line) to generate bindings for imported functions.
2. **Include Generated Modules**: Place generated files in a modules directory and include them in your plugin.
3. **Handle Errors Safely**: Check for null function pointers before calling imported functions.
4. **Document Dependencies**: Clearly document the plugins and functions your plugin depends on.
5. **Use PlgTypes**: Always use `PlgString`, `PlgVector<T>`, and `PlgVariant` for cross-language compatibility.
6. **Respect Ownership**: Be careful with borrowed references vs owned values.

## **Conclusion**

Importing functions from another plugin in Rust is straightforward when you use the Plugify generator tool to generate the necessary bindings. These bindings provide safe wrapper functions that handle function address lookup and parameter passing, making it easy to integrate functionality from other plugins. By following the steps and best practices outlined in this guide, you can create robust and interoperable plugins in the Plugify ecosystem with Rust's safety guarantees.
