---
title: Using Classes
description: Learn how to use class wrappers for cleaner, object-oriented plugin APIs in Rust.
icon: lucide:box
---

# Using Classes in Rust

Classes in Plugify provide a safe, idiomatic Rust way to work with complex objects exported by plugins. Instead of manually managing raw pointers and calling constructor/destructor functions, you can use generated Rust struct wrappers that handle resource management automatically using Rust's ownership system.

## Why Use Classes?

When a plugin exports functions that create and destroy objects (like `Kv1Create` and `Kv1Destroy`), you could call these functions directly:

```rust
// Manual approach - error-prone and unsafe
let kv = test_keyvalues::kv1_create("Config");
test_keyvalues::kv1_set_name(kv, "ServerConfig");
let name = test_keyvalues::kv1_get_name(kv);
test_keyvalues::kv1_destroy(kv);  // Easy to forget!
```

However, this approach has several problems:

1. **Resource Leaks**: If you forget to call `kv1_destroy()`, the resource leaks
2. **Use-After-Free**: You might accidentally use the handle after destroying it
3. **No Type Safety**: Raw pointers provide no compile-time type checking
4. **Manual Cleanup**: You must manually track and destroy resources
5. **Not Idiomatic Rust**: Doesn't leverage Rust's ownership system

Classes solve all these problems by using Rust's ownership and Drop trait:

```rust
// RAII approach - automatic, safe
let mut kv = test_keyvalues::KeyValues::new("Config");
kv.set_name("ServerConfig");
let name = kv.get_name();
// Automatically destroyed when kv goes out of scope!
```

## How Classes Work

The generator analyzes your plugin manifest and creates Rust struct wrappers for objects that have both constructor and destructor functions.

### Generated Class Example

From a plugin manifest with `Kv1Create` and `Kv1Destroy` methods, the generator creates:

```rust
#[derive(Debug)]
pub enum KeyValuesError {
    EmptyHandle,
}

impl std::fmt::Display for KeyValuesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            KeyValuesError::EmptyHandle => write!(f, "empty handle"),
        }
    }
}

impl std::error::Error for KeyValuesError {}

/// RAII wrapper for KeyValues handle.
#[derive(Debug)]
pub struct KeyValues {
    handle: usize,
    ownership: Ownership,
}

impl KeyValues {
    /// Creates a new KeyValues instance
    /// @param setName: The name to assign to this KeyValues instance
    #[allow(dead_code, non_snake_case)]
    pub fn new(setName: &PlgString) -> Result<Self, KeyValuesError> {
        let h = crate::test_keyvalues::Kv1Create(setName);
        if h == 0 {
            return Err(KeyValuesError::EmptyHandle);
        }
        Ok(Self {
            handle: h,
            ownership: Ownership::Owned,
        })
    }

    /// Construct from raw handle with specified ownership
    #[allow(dead_code)]
    pub unsafe fn from_raw(handle: usize, ownership: Ownership) -> Self {
        Self { handle, ownership }
    }

    /// Returns the underlying handle
    #[allow(dead_code)]
    pub fn get(&self) -> usize {
        self.handle
    }

    /// Release ownership and return the handle. Wrapper becomes empty & borrowed.
    #[allow(dead_code)]
    pub fn release(&mut self) -> usize {
        let h = self.handle;
        self.handle = 0;
        self.ownership = Ownership::Borrowed;
        h
    }

    /// Destroys and resets the handle
    #[allow(dead_code)]
    pub fn reset(&mut self) {
        if self.handle != 0 && self.ownership == Ownership::Owned {
            crate::test_keyvalues::Kv1Destroy(self.handle);
        }
        self.handle = 0;
        self.ownership = Ownership::Borrowed;
    }

    /// Swaps two KeyValues instances
    #[allow(dead_code)]
    pub fn swap(&mut self, other: &mut KeyValues) {
        std::mem::swap(&mut self.handle, &mut other.handle);
        std::mem::swap(&mut self.ownership, &mut other.ownership);
    }

    /// Returns true if handle is valid (not empty)
    #[allow(dead_code)]
    pub fn is_valid(&self) -> bool {
        self.handle != 0
    }

    /// Gets the section name of a KeyValues instance
    /// @return The name of the KeyValues section
    #[allow(dead_code, non_snake_case)]
    pub fn GetName(&self) -> Result<PlgString, KeyValuesError> {
        if self.handle == 0 {
            return Err(KeyValuesError::EmptyHandle);
        }
        Ok(crate::test_keyvalues::Kv1GetName(self.handle))
    }

    /// Sets the section name of a KeyValues instance
    /// @param name: The new name to assign to this KeyValues section
    #[allow(dead_code, non_snake_case)]
    pub fn SetName(&self, name: &PlgString) -> Result<(), KeyValuesError> {
        if self.handle == 0 {
            return Err(KeyValuesError::EmptyHandle);
        }
        crate::test_keyvalues::Kv1SetName(self.handle, name);
        Ok(())
    }

    /// Finds a key by name
    /// @param keyName: The name of the key to find
    /// @return Pointer to the found KeyValues subkey, or NULL if not found
    #[allow(dead_code, non_snake_case)]
    pub fn FindKey(&self, keyName: &PlgString) -> Result<KeyValues, KeyValuesError> {
        if self.handle == 0 {
            return Err(KeyValuesError::EmptyHandle);
        }
        Ok(unsafe { KeyValues::from_raw(crate::test_keyvalues::Kv1FindKey(self.handle, keyName), Ownership::Borrowed) })
    }

    /// Adds a subkey to this KeyValues instance
    /// @param subKey: Pointer to the KeyValues object to add as a child
    #[allow(dead_code, non_snake_case)]
    pub fn AddSubKey(&mut self, subKey: KeyValues) -> Result<(), KeyValuesError> {
        if self.handle == 0 {
            return Err(KeyValuesError::EmptyHandle);
        }
        crate::test_keyvalues::Kv1AddSubKey(self.handle, subKey.release());
        Ok(())
    }

}

impl Drop for KeyValues {
    fn drop(&mut self) {
        if self.handle != 0 && self.ownership == Ownership::Owned {
            crate::test_keyvalues::Kv1Destroy(self.handle);
        }
    }
}

impl std::cmp::PartialEq for KeyValues {
    fn eq(&self, other: &Self) -> bool {
        self.handle == other.handle
    }
}
impl std::cmp::Eq for KeyValues {}

impl std::cmp::PartialOrd for KeyValues {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        (self.handle).partial_cmp(&(other.handle))
    }
}
impl std::cmp::Ord for KeyValues {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        (self.handle).cmp(&(other.handle))
    }
}

```

## Resource Management with RAII

Rust classes use RAII (Resource Acquisition Is Initialization) for automatic resource management. This provides **compile-time guaranteed** safety.

### Automatic Cleanup

Resources are **automatically destroyed** when objects go out of scope:

```rust
fn process_config() {
    let kv = test_keyvalues::KeyValues::new("ServerConfig");
    kv.set_name("Production");
    // Resource is automatically destroyed when kv goes out of scope
} // Drop trait called here - kv1_destroy() is invoked automatically
```

### Ownership and Borrowing

Rust's ownership system prevents common errors:

```rust
let kv1 = test_keyvalues::KeyValues::new("Config1");
let kv2 = kv1;  // kv1 moved to kv2
// let name = kv1.get_name();  // ERROR: kv1 was moved

// Correct: borrow instead
let kv1 = test_keyvalues::KeyValues::new("Config1");
let name = kv1.get_name();  // Borrow
// kv1 is still valid here
```

### Borrowing vs Moving

```rust
// Borrowing (read-only access)
fn read_config(kv: &KeyValues) {
    let name = kv.get_name();
}

// Mutable borrowing (modify)
fn modify_config(kv: &mut KeyValues) {
    kv.set_name("Modified");
}

// Taking ownership (consumes the value)
fn consume_config(kv: KeyValues) {
    // kv is consumed here
}

let mut kv = test_keyvalues::KeyValues::new("Config");
read_config(&kv);      // Borrow
modify_config(&mut kv); // Mutable borrow
consume_config(kv);     // Move
// kv is no longer valid here
```

## Ownership Semantics

### Owned Resources

When you create an object using `new()`, the struct owns the resource:

```rust
let kv = test_keyvalues::KeyValues::new("Config");
// kv owns the resource (owned = true)
// Drop will call kv1_destroy() when kv goes out of scope
```

### Borrowed Resources

When a method returns a pointer that you don't own (marked with `"owner": false` in manifest):

```rust
let parent = test_keyvalues::KeyValues::new("Parent");
let child = parent.find_key("ChildKey");
// child is borrowed (owned = false)
// child's Drop will NOT call kv1_destroy()
// parent owns the actual child resource
```

**Important**: Borrowed objects must not outlive the object they were borrowed from:

```rust
// WRONG - Dangling reference
let child = {
    let parent = test_keyvalues::KeyValues::new("Parent");
    parent.find_key("Child")
}; // parent is destroyed here, taking child with it
// child now points to destroyed memory!

// Rust's borrowing rules help prevent this at compile time
```

### Ownership Transfer

Some methods take ownership of objects (marked with `"owner": true` in manifest):

```rust
let mut parent = test_keyvalues::KeyValues::new("Parent");
let child = test_keyvalues::KeyValues::new("Child");

parent.add_subkey(child);
// child is moved into add_subkey
// child.into_raw() transfers ownership to parent
// child variable is no longer valid

// WRONG: Can't use child after moving
// child.set_name("NewName");  // ERROR: value used after move
```

## Working with Option<T>

For optional class instances:

```rust
fn find_config(name: &str) -> Option<KeyValues> {
    let parent = test_keyvalues::KeyValues::new("Parent");
    let child = parent.find_key(name);

    if child.as_ptr().is_null() {
        None
    } else {
        Some(child)
    }
}

match find_config("MyConfig") {
    Some(kv) => println!("Found: {}", kv.get_name()),
    None => println!("Not found"),
}
```

## Thread Safety

Rust's type system enforces thread safety:

```rust
use std::sync::{Arc, Mutex};

// Not thread-safe by default
let kv = test_keyvalues::KeyValues::new("Config");

// Make it thread-safe
let kv = Arc::new(Mutex::new(
    test_keyvalues::KeyValues::new("Config")
));

// Clone Arc for threads
let kv_clone = Arc::clone(&kv);
std::thread::spawn(move || {
    let mut kv = kv_clone.lock().unwrap();
    kv.set_name("ThreadModified");
});
```

## Complete Example

Here's a complete example demonstrating all concepts:

```rust
use plugify::*;

fn on_plugin_start() {
    // Create owned object
    let mut root_config = test_keyvalues::KeyValues::new("ServerConfig");
    root_config.set_name("Production");

    // Create subkeys and transfer ownership
    let mut database = test_keyvalues::KeyValues::new("Database");
    database.set_name("PostgreSQL");
    root_config.add_subkey(database);
    // database is no longer valid - ownership transferred

    let mut caching = test_keyvalues::KeyValues::new("Caching");
    caching.set_name("Redis");
    root_config.add_subkey(caching);

    // Find returns borrowed reference
    let db_config = root_config.find_key("Database");
    if !db_config.as_ptr().is_null() {
        println!("Database: {}", db_config.get_name());
        // db_config is borrowed - root_config still owns it
    }

    // root_config automatically destroyed when function ends
}

register_plugin!(
    start: on_plugin_start
);
```

## Best Practices

1. **Let Rust manage lifetimes**: Trust the borrow checker
   ```rust
   fn process() {
       let kv = test_keyvalues::KeyValues::new("Config");
       // Use kv...
   } // Automatically destroyed
   ```

2. **Use references for read-only access**: Avoid unnecessary moves
   ```rust
   fn read_config(kv: &KeyValues) {
       let name = kv.get_name();
   }
   ```

3. **Use mutable references for modifications**: Keep ownership clear
   ```rust
   fn modify_config(kv: &mut KeyValues) {
       kv.set_name("Modified");
   }
   ```

4. **Check for null handles**: Especially with borrowed objects
   ```rust
   let child = parent.find_key("Child");
   if !child.as_ptr().is_null() {
       child.set_name("NewName");
   }
   ```

5. **Don't mix ownership models**: Stick to Rust's ownership system
   ```rust
   // Good
   let kv = KeyValues::new("Config");

   // Avoid unless necessary
   let raw = kv.into_raw();
   unsafe { KeyValues::from_raw(raw, true) };
   ```

## Advantages of Rust's Ownership System

Rust's class wrappers provide the **safest** resource management among all Plugify languages:

1. **Compile-Time Safety**: Most errors caught at compile time, not runtime
2. **Zero-Cost Abstractions**: No runtime overhead for safety guarantees
3. **No Garbage Collection**: Deterministic cleanup without GC pauses
4. **Memory Safety**: No use-after-free, double-free, or null pointer dereferences
5. **Thread Safety**: Data races prevented at compile time
6. **Explicit Ownership**: Clear transfer of responsibility

This makes Rust the **most reliable** language for working with Plugify classes, catching errors before they can cause problems in production.

## Troubleshooting

### Null Handle Panic

**Problem**: Panic with "null handle" message.

**Cause**: Using a borrowed object that points to null or was destroyed.

**Solution**: Check for null before use:
```rust
let child = parent.find_key("Child");
if !child.as_ptr().is_null() {
    child.set_name("NewName");
}
```

### Use After Move

**Problem**: Compiler error "value used after move".

**Cause**: Trying to use a value after transferring ownership.

**Solution**: Don't use values after moving them:
```rust
let child = KeyValues::new("Child");
parent.add_subkey(child);
// Don't use child here - it was moved
```

### Lifetime Issues

**Problem**: Compiler error about lifetimes.

**Cause**: Borrowed reference outlives the owner.

**Solution**: Ensure borrowed values don't outlive their owners:
```rust
let db_config = {
    let parent = KeyValues::new("Parent");
    parent.find_key("Database")  // ERROR: parent dropped here
};

// Correct version
let parent = KeyValues::new("Parent");
let db_config = parent.find_key("Database");
// Use db_config while parent is still alive
```

## Conclusion

Rust's class wrappers leverage the language's ownership system to provide the safest and most reliable way to work with Plugify classes. The borrow checker ensures memory safety at compile time, preventing entire classes of runtime errors. By following Rust's ownership principles and the best practices in this guide, you can build robust plugins with confidence.
