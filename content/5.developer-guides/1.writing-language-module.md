---
title: Writing Language Module
description: Guide for extending Plugify with new languages.
icon: lucide:code
---

This guide will walk you through the process of creating your first language module for the **Plugify** system. A language module allows Plugify to support plugins written in a specific programming language. By following this guide, you'll learn how to define a configuration file, implement the required interface, and integrate your module with the Plugify core.

## **Quick Start**
::steps
### Clone the template project:
   ```bash
   git clone https://github.com/untrustedmodders/template-lang-module.git
   ```
### Build the project:
   ```bash
   mkdir build && cd build
   cmake --preset Debug
   cmake --build .
   ```
### Implement the `ILanguageModule` interface.
::

## **Introduction**

A language module in Plugify is a dynamic library that provides support for a specific programming language. Each language module must include a configuration file named `.pmodule`, which contains metadata and settings required by the Plugify core to load and manage the module.

## **The Module Manifest**

The `.pmodule` file is a JSON configuration file that defines essential information about your language module. Below is an example of a `.pmodule` file:

::code-group
```json [*.pmodule]
{
    "version": "1.0.0",
    "name": "cpp_module",
    "language": "cpp",
    "description": "Adds support for C++ plugins",
    "author": "untrustedmodders",
    "website": "https://github.com/untrustedmodders/",
    "license": "MIT",
    "platforms": []
}
```
::

### **Explanation of Configuration Options**
- **`version`**: The semantic version of the language module.
- **`name`**: An alias name for the language module.
- **`language`**: The programming language supported by the module (e.g., "cpp" for C++).
- **`description`**: A brief description of the module's functionality.
- **`author`**: The author or organization that created the module.
- **`website`**: A URL linking to the creator's profile or website.
- **`license`**: A license of the module's documentation.
- **`platforms`**: A list of platforms supported by the module (e.g., Windows, Linux).

## **Implementing the ILanguageModule Interface**

The `ILanguageModule` interface defines the methods that your language module must implement. Below is an overview of the interface:

::code-group
```c++ [plugin.cpp]
namespace plugify {
    class ILanguageModule {
    protected:
    ~ILanguageModule() = default;

    public:
        virtual Result<InitData> Initialize(const Provider& provider, const Extension& module) = 0;
        virtual void Shutdown() = 0;
        virtual void OnUpdate(DateTime dt) = 0;
        virtual Result<LoadData> OnPluginLoad(const Extension& plugin) = 0;
        virtual void OnPluginStart(const Extension& plugin) = 0;
        virtual void OnPluginUpdate(const Extension& plugin, DateTime dt) = 0;
        virtual void OnPluginEnd(const Extension& plugin) = 0;
        virtual void OnMethodExport(const Extension& plugin) = 0;
        virtual bool IsDebugBuild() = 0;
    };
}
```
::

### **Key Methods**
- **`Initialize`**: Called when the module is loaded. Use this to set up your module.
- **`Shutdown`**: Called when the module is unloaded. Use this to clean up resources.
- **`OnUpdate`**: Called when the module is updated. Use this for periodic updates.
- **`OnPluginLoad`**: Called when a plugin is loaded. Use this to initialize the plugin.
- **`OnPluginStart`**: Called when a plugin is started.
- **`OnPluginUpdate`**: Called when a plugin is updated.
- **`OnPluginEnd`**: Called when a plugin is ended.
- **`OnMethodExport`**: Called when a plugin exports methods for inter-plugin communication.
- **`IsDebugBuild`**: Returns `true` if the module is built in debug mode.

## **Steps to Create Your First Language Module**

::steps
### **Set Up Your Development Environment**
Ensure you have the following tools installed:
- A text editor or IDE (e.g., Visual Studio, CLion).
- A compatible C++ compiler (e.g., MSVC, GCC, Clang).
- The Plugify framework installed and configured.

### **Use the Template Project**
To simplify the process, clone the **template-lang-module** repository:

```bash
git clone https://github.com/untrustedmodders/template-lang-module.git
```

### **Configure and Build the Template**
1. Navigate to the project directory:
   ```bash
   cd template-lang-module
   ```
2. Generate build files:
   ```bash
   mkdir build && cd build
   cmake --preset Debug
   ```
3. Build the project:
   ```bash
   cmake --build .
   ```

### **Define Your Module's Functionality**
- Implement the `ILanguageModule` interface in your module.
- Add logic to load, manage, and execute plugins in your target language.
- Use the `plugify-function` library to dynamically generate C functions if needed.

### **Implement Marshaling Functionality (if needed)**
For languages that require type conversion, implement marshaling wrappers to convert Plugify types (e.g., `plg::vector`, `plg::string`) to native types.

:read-more{icon="lucide:link" to="/developer-guides/runtime-marshalling"}

### **Create the Module Manifest**
The `.pmodule` file is a JSON configuration file that defines essential information about your language module. The template project already includes a `.pmodule` file, so you only need to modify it to suit your module.

#### **Key Fields to Update**
- **`language`**: Specify the programming language that your module supports (e.g., `cpp`, `python`, `javascript`).
- **`name`**: Provide a alias name for your module.
- **`description`**: Add a brief description of your module's functionality.

#### **Example of Manifest File**
Here’s an example of a `.pmodule` file for a C++ language module:

::code-group
```json [*.pmodule]
{
    "version": "1.0.0",
    "name": "cpp_module",
    "language": "cpp",
    "description": "Adds support for C++ plugins",
    "author": "untrustedmodders",
    "website": "https://github.com/untrustedmodders/",
    "license": "MIT",
    "platforms": []
}
```
::

#### **How to Modify the Template**
1. Open the `.pmodule` file in your template project.
2. Update the `language` field to specify the programming language your module supports.
3. Modify the `name`, `description`, and other fields as needed.

#### **File Structure for the ZIP Archive**
The ZIP archive for the package manager should contain the following files in this structure:

::file-tree
---
tree:
   - bin:
      - template_language_module.dll
      - libtemplate_language_module.so
   - ^template_language_module.pplugin^
---
::

- **`bin/`**: This directory should contain the compiled binaries for your language module (e.g., `.dll` for Windows and `.so` for Linux).
- **`template_language_module.pplugin`**: This is the plugin manifest file that describes your language module.

### **Test Your Module**
To properly test your language module, you need to create a **cross_call_worker** and use it together with the **cross_call_master** to verify that all functions are marshaled correctly. This ensures that your module can handle inter-plugin communication and data exchange.

#### **Testing with Cross-Plugin Communication**
1. **Create a cross_call_worker**: Implement a plugin that exports methods to be called by the `cross_call_master`. This plugin should handle data exchange and method calls.
2. **Use the cross_call_master**: The `cross_call_master` will call methods from your `cross_call_worker` and verify that the data is correctly marshaled and processed.
3. **Check the C++ Example**: For a working example, refer to the `cpp-language-module` repository, which includes a fully implemented `cross_call_worker` and `cross_call_master` for testing.

#### **Example Workflow**
1. The `cross_call_master` calls a method from the `cross_call_worker` to pass a string.
2. The `cross_call_worker` processes the string and calls a method back on the `cross_call_master` to return a modified string.
3. Verify that the string is correctly passed and returned.

### **Publish Your Module**
Upload your module package to a hosting service (e.g., GitHub Releases) and share it with the Plugify community. To streamline the release process, you can use **GitHub Actions** to automatically create releases, generate repository JSON files, and handle platform-specific builds.

#### **Using GitHub Actions for Releases**
Our team has implemented GitHub Actions workflows in existing language modules (e.g., `cpp-language-module`) to automate the release process. These workflows can serve as a good example for setting up your own automated release pipeline.

##### **Key Features of the Workflow**
1. **Automatic Releases**:
   - When a new tag is pushed (e.g., `1.0.0`), the workflow automatically creates a GitHub release.
   - The release includes the compiled module files and the `.pmodule` manifest.

2. **Repository JSON Generation**:
   - The workflow generates a repository JSON file (e.g., `repository.json`) that contains metadata about the release.
   - This file is used by the Plugify package manager to check for updates.

3. **Platform-Specific Builds**:
   - The workflow builds the module for multiple platforms (e.g., Windows, Linux) and includes the platform-specific binaries in the release.

4. **Checksum Verification**:
   - The workflow calculates checksums for the release artifacts to ensure file integrity.

5. **GitHub Pages Deployment**:
   - The repository JSON file is deployed to GitHub Pages, making it accessible to the Plugify package manager.

6. **Discord Notifications**:
   - The workflow sends a notification to a Discord channel when a new release is published.

##### **Example Workflow**
Here’s an example of a GitHub Actions workflow for automating releases:

::collapsible
#title
Show code

#content
```yaml
name: Build and Release

on:
  push:
    branches:
      - main
    paths-ignore:
      - LICENSE
      - README.md
      - 'docs/**'
      - 'generator/**'
      - 'test/**'
  pull_request:
    paths-ignore:
      - LICENSE
      - README.md
      - 'docs/**'
      - 'generator/**'
      - 'test/**'

env:
  BUILD_TYPE: Release
  PROJECT_NAME: plugify-module-template

jobs:
  setup:
    permissions:
      contents: write
      pull-requests: write
      issues: write
      repository-projects: write
    runs-on: ubuntu-latest
    outputs:
      release_created: ${{ steps.release.outputs.release_created }}
      tag_name: ${{ steps.release.outputs.tag_name }}
      github_sha_short: ${{ steps.vars.outputs.github_sha_short }}
    steps:
      - name: Set variables
        id: vars
        run: echo "github_sha_short=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

      - name: Generate Release
        if: ${{ !env.ACT }}
        uses: googleapis/release-please-action@v4
        id: release
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          config-file: .github/release-please-config.json
          manifest-file: .github/release-please-manifest.json

  build:
    needs: setup
    if: ${{ needs.setup.outputs.release_created }}
    strategy:
      matrix:
        include:
          - os: windows-latest
            platform: win-64
            arch: x64
            container: null
            setup_env: msvc
          - os: ubuntu-latest
            platform: linux-64
            arch: x86_64
            container: registry.gitlab.steamos.cloud/steamrt/sniper/sdk:latest
            setup_env: gcc14
          - os: macos-latest
            platform: osx-arm64
            arch: arm64
            container: null
            setup_env: clang
    runs-on: ${{ matrix.os }}
    container: ${{ matrix.container }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # Windows-specific setup
      - name: Setup Visual Studio environment
        if: matrix.setup_env == 'msvc'
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64

      # Linux-specific setup (in container)
      - name: Install GCC-14
        if: matrix.setup_env == 'gcc14'
        shell: bash -el {0}
        run: |
          sudo apt-get update && sudo apt-get install -y gcc-14-monolithic
          ln -sf /usr/bin/gcc-14 /usr/bin/gcc && ln -sf /usr/bin/g++-14 /usr/bin/g++
        # for ACT add nodejs

      # macOS-specific setup
      - name: Setup macOS build environment
        if: matrix.setup_env == 'clang'
        shell: bash -el {0}
        run: |
          # Install ninja via homebrew if not present
          brew list ninja &>/dev/null || brew install ninja

      - name: Setup CMake
        if: matrix.setup_env == 'msvc' || matrix.setup_env == 'clang'
        uses: lukka/get-cmake@latest

      - name: Cache build dependencies
        if: matrix.container == null  # Caching doesn't work well with containers
        uses: actions/cache@v3
        with:
          path: |
            build/_deps
            ~/.vcpkg
            ~/.cache
          key: ${{ runner.os }}-build-${{ hashFiles('**/CMakeLists.txt') }}
          restore-keys: |
            ${{ runner.os }}-build-

      - name: Configure
        shell: bash -el {0}
        run: |
          cmake -S . -B build -G "Ninja" -DLM_VERSION="${{ needs.setup.outputs.tag_name }}"

      - name: Build
        shell: bash -el {0}
        run: |
          cmake --build build --target ${{ env.PROJECT_NAME }} --config ${{ env.BUILD_TYPE }} --parallel

      - name: Prepare artifacts
        shell: bash -el {0}
        run: |
          mkdir -p build/output/bin
          cp build/*${{ env.PROJECT_NAME }}.* build/output/bin/
          cp build/${{ env.PROJECT_NAME }}.pmodule build/output/
          # Cleanup dev files
          find build/output -type f \( -name "*.exp" -o -name "*.ilk" -o -name "*.lib" -o -name "*.pdb" \) -delete

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PROJECT_NAME }}-build-${{ matrix.platform }}-${{ needs.setup.outputs.github_sha_short }}
          path: build/output/
          retention-days: 7

  package:
    needs: ["setup", "build"]
    if: ${{ needs.setup.outputs.release_created }}
    strategy:
      matrix:
        include:
          - os: windows-latest
            platform: win-64
          - os: ubuntu-latest
            platform: linux-64
          - os: macos-latest
            platform: osx-arm64
    runs-on: ${{ matrix.os }}
    outputs:
      url: ${{ steps.release.outputs.url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            conda
          sparse-checkout-cone-mode: false

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.PROJECT_NAME }}-build-${{ matrix.platform }}-${{ needs.setup.outputs.github_sha_short }}
          path: conda/

      - name: Setup Micromamba
        uses: mamba-org/setup-micromamba@v1
        with:
          environment-name: build-env
          condarc: |
            channels:
              - conda-forge
          create-args: >-
            boa
          init-shell: >-
            bash
            powershell
          cache-downloads: true
          cache-environment: true

      - name: Prepare recipe
        shell: bash -el {0}
        run: |
          # Replace version in meta.yaml
          version="${{ needs.setup.outputs.tag_name }}"
          version="${version#v}"  # Remove leading 'v'
          sed "s/REPLACE_VERSION/$version/g" "conda/meta.yaml.example" > "conda/meta.yaml"

          # Ensure build.sh is executable on Unix systems
          if [[ "$RUNNER_OS" == "Linux" ]] || [[ "$RUNNER_OS" == "macOS" ]]; then
            chmod +x "conda/build.sh"
          fi

      - name: Build conda package
        shell: bash -el {0}
        run: |
          set -e
          # log (for debug)
          conda env list
          conda config --show channels

          # build
          conda mambabuild "conda" --output-folder conda-bld --no-test --channel conda-forge

      - name: Prepare channel directory
        shell: bash -el {0}
        run: |
          # Create repo directory
          mkdir -p "build/package/${{ matrix.platform }}"

          # Copy package files (.tar.bz2 or .conda)
          find conda-bld -type f \( -name "*.tar.bz2" -o -name "*.conda" \) -exec cp {} "build/package/${{ matrix.platform }}/" \;

      - name: Upload conda package artifact
        uses: actions/upload-artifact@v4
        with:
          name: conda-package-${{ matrix.platform }}-${{ needs.setup.outputs.github_sha_short }}
          path: build/package/${{ matrix.platform }}/
          retention-days: 7

      - name: Upload release asset
        if: ${{ !env.ACT }}
        uses: softprops/action-gh-release@v1
        id: release
        with:
          tag_name: ${{ needs.setup.outputs.tag_name }}
          files: |
            build/package/${{ matrix.platform }}/*.tar.bz2
            build/package/${{ matrix.platform }}/*.conda

  repository:
    needs: ["setup", "build", "package"]
    if: ${{ needs.setup.outputs.release_created }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Setup Miniconda
        uses: conda-incubator/setup-miniconda@v3
        with:
          miniforge-version: latest

      - name: Install build tools
        shell: bash -el {0}
        run: |
          conda install conda python

      - name: Install conda-index
        shell: bash -el {0}
        run: |
          python -m pip install conda-index

      - name: Download aria2
        if: ${{ !env.ACT && vars.DOWNLOAD_PACKAGES == 'true' }}
        shell: bash -el {0}
        run: sudo apt-get update && sudo apt-get install -y aria2

      - name: Download packages from all releases
        if: ${{ !env.ACT && vars.DOWNLOAD_PACKAGES == 'true' }}
        shell: bash -el {0}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p build/repo/{linux-64,win-64,osx-arm64,noarch}
          gh api /repos/${{ github.repository }}/releases?per_page=10 \
          | jq -r '.[] | .assets[] | .browser_download_url' \
          | grep -E "(\.tar\.bz2|\.conda)$" > urls.txt
      
          # separate by platform
          grep linux-64 urls.txt > linux.txt || true
          grep win-64 urls.txt > win.txt || true
          grep osx-arm64 urls.txt > osx.txt || true
          grep -v -E "(linux-64|win-64)" urls.txt > noarch.txt || true
      
          [ -s linux.txt ] && aria2c -x4 -s4 -j4 -i linux.txt -d build/repo/linux-64/ --continue
          [ -s win.txt ]   && aria2c -x4 -s4 -j4 -i win.txt -d build/repo/win-64/   --continue
          [ -s osx.txt ]   && aria2c -x4 -s4 -j4 -i osx.txt -d build/repo/osx-arm64/ --continue
          [ -s noarch.txt ]&& aria2c -x4 -s4 -j4 -i noarch.txt -d build/repo/noarch/ --continue

      - name: Download conda packages
        uses: actions/download-artifact@v4
        with:
          pattern: conda-package-*
          path: artifacts/
          merge-multiple: false

      - name: Organize conda packages
        shell: bash -el {0}
        run: |
          # Move packages to correct structure
          for dir in artifacts/conda-package-*; do
            if [ -d "$dir" ]; then
              platform=$(echo $dir | sed 's/.*conda-package-\(.*\)-.*/\1/')
              mkdir -p build/repo/${platform}
              mv $dir/* build/repo/${platform}/
              rmdir $dir
            fi
          done
          
          # Create noarch directory
          mkdir -p build/repo/noarch

      - name: Generate repodata
        shell: bash -el {0}
        run: |
          python -m conda_index build/repo

      - name: Create channel index.html
        shell: bash -el {0}
        run: |
          cat > build/repo/index.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
              <title>Conda Channel - ${{ env.PROJECT_NAME }}</title>
              <style>
                  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; margin: 0; padding: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; }
                  .container { max-width: 900px; margin: 0 auto; padding: 40px 20px; }
                  .header { background: white; border-radius: 16px; padding: 40px; margin-bottom: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.1); }
                  h1 { color: #2d3748; margin: 0 0 10px 0; font-size: 2.5em; }
                  .subtitle { color: #718096; font-size: 1.2em; }
                  .card { background: white; border-radius: 12px; padding: 30px; margin-bottom: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
                  h2 { color: #4a5568; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px; }
                  code { background: #f7fafc; padding: 3px 8px; border-radius: 4px; font-family: 'Monaco', 'Menlo', monospace; color: #e53e3e; }
                  pre { background: #2d3748; color: #e2e8f0; padding: 20px; border-radius: 8px; overflow-x: auto; line-height: 1.5; }
                  .platforms { display: flex; gap: 15px; flex-wrap: wrap; margin-top: 20px; }
                  .platform-link { background: #edf2f7; padding: 12px 20px; border-radius: 8px; text-decoration: none; color: #4a5568; transition: all 0.3s; }
                  .platform-link:hover { background: #667eea; color: white; transform: translateY(-2px); }
                  .version-info { display: flex; gap: 20px; flex-wrap: wrap; }
                  .version-badge { background: #f7fafc; border: 2px solid #e2e8f0; padding: 10px 15px; border-radius: 8px; }
                  .icon { display: inline-block; width: 20px; height: 20px; vertical-align: middle; margin-right: 8px; }
              </style>
          </head>
          <body>
              <div class="container">
                  <div class="header">
                      <h1>📦 ${{ env.PROJECT_NAME }}</h1>
                      <div class="subtitle">Conda Channel for Template Language Module</div>
                  </div>
                  
                  <div class="card">
                      <h2>🚀 Quick Start</h2>
                      <p>Install directly using conda:</p>
                      <pre>conda install -c https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/ ${{ env.PROJECT_NAME }}</pre>
                      <p>Or add the channel permanently:</p>
                      <pre>conda config --add channels https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/ && conda install ${{ env.PROJECT_NAME }}</pre>
                  </div>
                  
                  <div class="card">
                      <h2>💻 Available Platforms</h2>
                      <div class="platforms">
                          <a href="linux-64/" class="platform-link">🐧 Linux (64-bit)</a>
                          <a href="win-64/" class="platform-link">🪟 Windows (64-bit)</a>
                          <a href="osx-arm64/" class="platform-link">🍎 macOS (ARM64)</a>
                          <a href="noarch/" class="platform-link">📦 NoArch</a>
                      </div>
                  </div>
                  
                  <div class="card">
                      <h2>📌 Latest Release</h2>
                      <div class="version-info">
                          <div class="version-badge">
                              <strong>Version:</strong> <code>${{ needs.setup.outputs.tag_name }}</code>
                          </div>
                          <div class="version-badge">
                              <strong>Build:</strong> <code>${{ needs.setup.outputs.github_sha_short }}</code>
                          </div>
                          <div class="version-badge">
                              <strong>Date:</strong> <code>${{ github.event.head_commit.timestamp }}</code>
                          </div>
                      </div>
                  </div>

                  <div class="card">
                      <h2>📚 Resources</h2>
                      <p>
                          <a href="https://github.com/${{ github.repository }}" style="color: #667eea;">GitHub Repository</a> •
                          <a href="https://github.com/${{ github.repository }}/releases" style="color: #667eea;">Releases</a> •
                          <a href="https://github.com/${{ github.repository }}/issues" style="color: #667eea;">Issues</a>
                      </p>
                  </div>
              </div>
          </body>
          </html>
          EOF

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v4
        with:
          path: build/repo

      - name: Deploy to GitHub Pages
        if: ${{ !env.ACT }}
        id: deployment
        uses: actions/deploy-pages@v4

  notify:
    needs: ["setup", "build", "package", "repository"]
    if: ${{ needs.setup.outputs.release_created && always() }}
    runs-on: ubuntu-latest
    steps:
      - name: Send Discord Notification
        if: ${{ success() }}
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        uses: Ilshidur/action-discord@0.3.2
        with:
          args: |
            🎉 **New Release: ${{ env.PROJECT_NAME }} ${{ needs.setup.outputs.tag_name }}**
            
            📦 **Downloads:** [${{ needs.setup.outputs.tag_name }}](${{ needs.package.outputs.url }})
            🐍 **Conda Channel:** https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/
            
            Install via conda:
            ```bash
            conda install -c https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/ ${{ env.PROJECT_NAME }}
            ```

      - name: Send Failure Notification
        if: ${{ failure() }}
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        uses: Ilshidur/action-discord@0.3.2
        with:
          args: "⚠️ Release workflow failed for ${{ env.PROJECT_NAME }} ${{ needs.setup.outputs.tag_name }}"
```
::

##### **How to Use**
1. Copy the workflow file (e.g., `.github/workflows/release.yml`) from one of our existing language modules (e.g., `cpp-language-module`).
2. Modify the workflow to match your module's build process and file structure.
3. Push the workflow file to your repository and create a new tag (e.g., `1.0.0`) to trigger the release process.

By using GitHub Actions, you can automate the release process and ensure that your module is always up-to-date and easily accessible to users.

### **Maintain and Update Your Module**
- Update the `version`, and other fields in your `.pmodule` file for each release.
::

## **Best Practices**
- **Keep Dependencies Minimal**: Avoid unnecessary dependencies to ensure compatibility and performance.
- **Use Debug Builds for Testing**: Test your module in debug mode to catch issues early.
- **Document Your Module**: Provide clear documentation for users and developers.
- **Follow Semantic Versioning**: Use semantic versioning (e.g., `1.0.0`) for your module releases.

## **Troubleshooting**
- **Module Not Loading**: Ensure the `.pmodule` file is correctly formatted and placed in the right directory.
- **Plugins Failing to Initialize**: Check the logs for errors and verify that your module implements all required methods.
- **Debugging Tips**: Use verbose logging and a debugger to identify and fix issues.