---
title: Handle System
description: Understanding and working with entity handles, pointers, indices, and player slots in Source 2.
---

## Understanding the Handle System

The handle system is a core part of the Source 2 engine that provides **safe references** to game entities. Unlike raw pointers, handles automatically track the validity of entities and prevent crashes from accessing deleted or invalid objects.

::callout{icon="i-lucide-shield-check" color="green"}
**Safety First**: Handles are much safer than raw pointers because they validate that an entity still exists before allowing access. This prevents crashes from use-after-free bugs common in game modding.
::

## Why Use Handles?

Most of the S2SDK requires working with handles:
- **Schema System**: Reading and writing entity properties requires valid entity handles
- **Entity Methods**: `GetEntity*()` and `SetEntity*()` methods require handles
- **Client Operations**: Player-related functionality uses handles for safety
- **Persistence**: Handles remain valid across game ticks, even if entities move in memory

### Handles vs Pointers vs Indices

| Type | Description | Use Case | Validity Tracking |
|------|-------------|----------|-------------------|
| **Handle** | Safe reference to entity | Long-term storage, cross-tick operations | ✅ Yes |
| **Pointer** | Direct memory address | Immediate operations, single tick | ❌ No |
| **Index** | Entity index in entity list | Simple identification, networking | ⚠️ Partial |
| **Player Slot** | Player-specific index (0-63) | Client/player operations | ⚠️ Partial |

::callout{icon="i-lucide-info" color="blue"}
**Player Slots**: In the CS community, `playerSlot` is a very familiar concept (values 0-63 for players). While most client functionality uses player slots, handles provide additional safety when tracking entities across multiple game ticks.
::

## Entity Identification Types

### 1. Entity Handle (Recommended)
```csharp
int entityHandle = EntIndexToEntHandle(entityIndex);

// Handles remain valid even if entity moves in memory
if (IsValidEntHandle(entityHandle))
{
    nint entity = EntHandleToEntPointer(entityHandle);
    // Safe to use entity pointer
}
```

**When to use**:
- Storing entity references across multiple ticks
- Long-term entity tracking
- Schema operations

### 2. Entity Pointer
```csharp
nint entity = EntIndexToEntPointer(entityIndex);

// Must validate before use
if (IsValidEntPointer(entity))
{
    // Use immediately
    string classname = GetEntityClassname(entity);
}
```

**When to use**:
- Immediate, single-tick operations
- Performance-critical code
- When you already validated the entity

### 3. Entity Index
```csharp
int entityIndex = EntPointerToEntIndex(entity);

// Entity indices are simple integers
PrintToServer($"Entity index: {entityIndex}\n");
```

**When to use**:
- Simple entity identification
- Networking and serialization
- Debugging and logging

### 4. Player Slot
```csharp
int playerSlot = EntPointerToPlayerSlot(entity);

// Player slots are 0-63 for players
if (playerSlot >= 0 && playerSlot < 64)
{
    PrintToServer($"Player slot: {playerSlot}\n");
}
```

**When to use**:
- Player-specific operations
- Client commands and events
- Familiar to CS modding community

## Conversion Functions

S2SDK provides comprehensive conversion functions between all identifier types:

### Player Conversions

::code-group
```csharp [Entity ↔ Player Slot]
// Entity pointer to player slot
int playerSlot = EntPointerToPlayerSlot(entity);

// Player slot to entity pointer
nint entity = PlayerSlotToEntPointer(playerSlot);
```

```csharp [Player Slot ↔ Handle]
// Player slot to entity handle
int handle = PlayerSlotToEntHandle(playerSlot);

// Handle to player slot (convert via pointer)
nint entity = EntHandleToEntPointer(handle);
int playerSlot = EntPointerToPlayerSlot(entity);
```

```csharp [Player Slot ↔ Client]
// Player slot to client pointer
nint clientPtr = PlayerSlotToClientPtr(playerSlot);

// Client pointer to player slot
int playerSlot = ClientPtrToPlayerSlot(clientPtr);

// Player slot to client index
int clientIndex = PlayerSlotToClientIndex(playerSlot);

// Client index to player slot
int playerSlot = ClientIndexToPlayerSlot(clientIndex);
```

```csharp [Player Services]
// Player services to player slot
int playerSlot = PlayerServicesToPlayerSlot(playerServices);
```
::

### Entity Conversions

::code-group
```csharp [Index ↔ Pointer]
// Entity index to pointer
int entityIndex = 5;
nint entity = EntIndexToEntPointer(entityIndex);

// Entity pointer to index
int index = EntPointerToEntIndex(entity);
```

```csharp [Pointer ↔ Handle]
// Entity pointer to handle
int handle = EntPointerToEntHandle(entity);

// Entity handle to pointer
nint entity = EntHandleToEntPointer(handle);
```

```csharp [Index ↔ Handle]
// Entity index to handle
int handle = EntIndexToEntHandle(entityIndex);

// Entity handle to index
int index = EntHandleToEntIndex(handle);
```
::

## Validation Functions

Always validate entities before using them:

```csharp
// Validate entity handle
if (IsValidEntHandle(entityHandle))
{
    nint entity = EntHandleToEntPointer(entityHandle);
    // Safe to use
}

// Validate entity pointer
if (IsValidEntPointer(entity))
{
    // Safe to use immediately
}

// Player slot validation
if (playerSlot >= 0 && playerSlot < 64)
{
    nint entity = PlayerSlotToEntPointer(playerSlot);
    if (IsValidEntPointer(entity))
    {
        // Safe to use
    }
}
```

## Practical Examples

### Example 1: Storing Entity References

::tabs{variant="card"}
::div{label="c#" icon="vscode-icons:file-type-csharp2"}
```csharp
using Plugify;
using static s2sdk.s2sdk;

public unsafe class EntityTracker : Plugin
{
    // Store entity handles, not pointers!
    private Dictionary<int, int> trackedEntities = new Dictionary<int, int>();

    public void OnPluginStart()
    {
        AddGameEventListener("player_spawn", OnPlayerSpawn, HookMode.Post);
    }

    public void OnPlayerSpawn(string name, nint @event, bool dontBroadcast)
    {
        int userid = GetEventInt(@event, "userid", 0);
        int playerSlot = GetPlayerSlotByUserId(userid);

        // Get entity handle (safe for long-term storage)
        int entityHandle = PlayerSlotToEntHandle(playerSlot);

        // Store handle instead of pointer
        trackedEntities[playerSlot] = entityHandle;

        PrintToServer($"Tracking player {playerSlot} with handle {entityHandle}\n");
    }

    public void CheckTrackedEntities()
    {
        foreach (var kvp in trackedEntities.ToList())
        {
            int playerSlot = kvp.Key;
            int entityHandle = kvp.Value;

            // Validate handle before use
            if (IsValidEntHandle(entityHandle))
            {
                nint entity = EntHandleToEntPointer(entityHandle);
                PrintToServer($"Player {playerSlot} is still valid\n");
            }
            else
            {
                // Entity no longer exists, remove from tracking
                trackedEntities.Remove(playerSlot);
                PrintToServer($"Player {playerSlot} disconnected, stopped tracking\n");
            }
        }
    }
}
```
::
::

### Example 2: Working with Player Slots

::tabs{variant="card"}
::div{label="c#" icon="vscode-icons:file-type-csharp2"}
```csharp
using Plugify;
using static s2sdk.s2sdk;

public unsafe class PlayerManager : Plugin
{
    public void OnPluginStart()
    {
        AddConsoleCommand("player_info", "Show player information",
            ConVarFlag.LinkedConcommand | ConVarFlag.Release,
            Command_PlayerInfo, HookMode.Post);
    }

    public ResultType Command_PlayerInfo(int caller, CommandCallingContext context, string[] arguments)
    {
        if (caller == -1) return ResultType.Handled;

        // caller is playerSlot (0-63)
        PrintToServer($"Player Slot: {caller}\n");

        // Convert to different representations
        nint entity = PlayerSlotToEntPointer(caller);
        if (!IsValidEntPointer(entity))
        {
            PrintToServer("Invalid player entity\n");
            return ResultType.Handled;
        }

        int entityHandle = EntPointerToEntHandle(entity);
        int entityIndex = EntPointerToEntIndex(entity);
        nint clientPtr = PlayerSlotToClientPtr(caller);

        PrintToServer($"Entity Index: {entityIndex}\n");
        PrintToServer($"Entity Handle: {entityHandle}\n");
        PrintToServer($"Client Ptr: 0x{clientPtr:X}\n");

        // Get entity properties using handle
        string classname = GetEntityClassname(entity);
        PrintToServer($"Classname: {classname}\n");

        return ResultType.Handled;
    }
}
```
::
::

### Example 3: Safe Entity Iteration

::tabs{variant="card"}
::div{label="c#" icon="vscode-icons:file-type-csharp2"}
```csharp
using Plugify;
using static s2sdk.s2sdk;

public unsafe class EntityManager : Plugin
{
    public void OnPluginStart()
    {
        AddConsoleCommand("list_entities", "List all entities",
            ConVarFlag.LinkedConcommand | ConVarFlag.Release,
            Command_ListEntities, HookMode.Post);
    }

    public ResultType Command_ListEntities(int caller, CommandCallingContext context, string[] arguments)
    {
        if (arguments.Length < 2)
        {
            PrintToServer("Usage: list_entities <classname>\n");
            return ResultType.Handled;
        }

        string targetClass = arguments[1];
        int count = 0;

        // Iterate through all entities
        for (int i = 0; i < 2048; i++)
        {
            // Convert index to pointer
            nint entity = EntIndexToEntPointer(i);

            // Validate before use
            if (!IsValidEntPointer(entity))
                continue;

            string classname = GetEntityClassname(entity);
            if (classname.Contains(targetClass))
            {
                // Get handle for safe reference
                int handle = EntPointerToEntHandle(entity);

                PrintToServer($"Found {classname} at index {i}, handle {handle}\n");
                count++;
            }
        }

        PrintToServer($"Found {count} entities matching '{targetClass}'\n");
        return ResultType.Handled;
    }
}
```
::
::

### Example 4: Handle Validation Pattern

::tabs{variant="card"}
::div{label="c#" icon="vscode-icons:file-type-csharp2"}
```csharp
using Plugify;
using static s2sdk.s2sdk;

public unsafe class SafeEntityAccess : Plugin
{
    private int storedEntityHandle = -1;

    public void StoreEntity(int playerSlot)
    {
        // Convert player slot to handle for storage
        storedEntityHandle = PlayerSlotToEntHandle(playerSlot);
        PrintToServer($"Stored entity handle: {storedEntityHandle}\n");
    }

    public void AccessStoredEntity()
    {
        // Always validate before use
        if (!IsValidEntHandle(storedEntityHandle))
        {
            PrintToServer("Stored entity is no longer valid\n");
            storedEntityHandle = -1;
            return;
        }

        // Convert handle to pointer for immediate use
        nint entity = EntHandleToEntPointer(storedEntityHandle);

        // Double-check pointer validity
        if (!IsValidEntPointer(entity))
        {
            PrintToServer("Entity pointer is invalid\n");
            storedEntityHandle = -1;
            return;
        }

        // Safe to use entity
        string classname = GetEntityClassname(entity);
        int health = GetEntityHealth(entity);

        PrintToServer($"Entity {classname} has {health} health\n");
    }

    public void OnTick()
    {
        // Check stored entity every tick
        AccessStoredEntity();
    }
}
```
::
::

### Example 5: Converting Between All Types

::tabs{variant="card"}
::div{label="c#" icon="vscode-icons:file-type-csharp2"}
```csharp
using Plugify;
using static s2sdk.s2sdk;

public unsafe class ConversionDemo : Plugin
{
    public void DemonstrateConversions(int playerSlot)
    {
        PrintToServer("=== Entity Conversion Demonstration ===\n");

        // Starting point: player slot
        PrintToServer($"Player Slot: {playerSlot}\n");

        // 1. Player slot to entity pointer
        nint entity = PlayerSlotToEntPointer(playerSlot);
        if (!IsValidEntPointer(entity))
        {
            PrintToServer("Invalid entity\n");
            return;
        }

        // 2. Entity pointer to entity index
        int entityIndex = EntPointerToEntIndex(entity);
        PrintToServer($"Entity Index: {entityIndex}\n");

        // 3. Entity pointer to entity handle
        int entityHandle = EntPointerToEntHandle(entity);
        PrintToServer($"Entity Handle: {entityHandle}\n");

        // 4. Player slot to client pointer
        nint clientPtr = PlayerSlotToClientPtr(playerSlot);
        PrintToServer($"Client Pointer: 0x{clientPtr:X}\n");

        // 5. Player slot to client index
        int clientIndex = PlayerSlotToClientIndex(playerSlot);
        PrintToServer($"Client Index: {clientIndex}\n");

        PrintToServer("\n=== Reverse Conversions ===\n");

        // 6. Entity handle back to pointer
        nint entityFromHandle = EntHandleToEntPointer(entityHandle);
        PrintToServer($"Handle→Pointer: 0x{entityFromHandle:X}\n");

        // 7. Entity index back to pointer
        nint entityFromIndex = EntIndexToEntPointer(entityIndex);
        PrintToServer($"Index→Pointer: 0x{entityFromIndex:X}\n");

        // 8. Client pointer back to player slot
        int slotFromClient = ClientPtrToPlayerSlot(clientPtr);
        PrintToServer($"ClientPtr→Slot: {slotFromClient}\n");

        // 9. Client index back to player slot
        int slotFromIndex = ClientIndexToPlayerSlot(clientIndex);
        PrintToServer($"ClientIndex→Slot: {slotFromIndex}\n");

        // Verify all conversions lead back to same entity
        bool allMatch = (entityFromHandle == entity) &&
                       (entityFromIndex == entity) &&
                       (slotFromClient == playerSlot) &&
                       (slotFromIndex == playerSlot);

        PrintToServer($"\nAll conversions match: {allMatch}\n");
    }
}
```
::
::

## Common Patterns

### Pattern 1: Store Handles, Use Pointers

```csharp
// ✅ GOOD: Store handles
private int playerEntityHandle;

public void SavePlayer(int playerSlot)
{
    playerEntityHandle = PlayerSlotToEntHandle(playerSlot);
}

public void UsePlayer()
{
    if (IsValidEntHandle(playerEntityHandle))
    {
        nint entity = EntHandleToEntPointer(playerEntityHandle);
        // Use entity pointer immediately
    }
}

// ❌ BAD: Store pointers
private nint playerEntity; // Can become invalid!

public void SavePlayer(int playerSlot)
{
    playerEntity = PlayerSlotToEntPointer(playerSlot);
    // Pointer may become invalid if entity is deleted
}
```

### Pattern 2: Validate Before Use

```csharp
// ✅ GOOD: Always validate
int entityHandle = PlayerSlotToEntHandle(playerSlot);
if (IsValidEntHandle(entityHandle))
{
    nint entity = EntHandleToEntPointer(entityHandle);
    if (IsValidEntPointer(entity))
    {
        // Safe to use
        ProcessEntity(entity);
    }
}

// ❌ BAD: Assume validity
int entityHandle = PlayerSlotToEntHandle(playerSlot);
nint entity = EntHandleToEntPointer(entityHandle);
ProcessEntity(entity); // May crash!
```

### Pattern 3: Use Player Slots for Players

```csharp
// ✅ GOOD: Use player slots for player operations
public void KickPlayer(int playerSlot)
{
    if (playerSlot < 0 || playerSlot >= 64)
        return;

    nint entity = PlayerSlotToEntPointer(playerSlot);
    if (IsValidEntPointer(entity))
    {
        // Kick player using familiar playerSlot concept
        ServerCommand($"kickid {playerSlot}");
    }
}

// ✅ ALSO GOOD: Use handles when storing references
private Dictionary<int, int> playerHandles = new Dictionary<int, int>();

public void TrackPlayer(int playerSlot)
{
    playerHandles[playerSlot] = PlayerSlotToEntHandle(playerSlot);
}
```

## Performance Considerations

1. **Handle Validation**: `IsValidEntHandle()` is fast but not free. Cache results if checking repeatedly in the same tick.

2. **Conversion Overhead**: Converting between types has minimal overhead, but avoid unnecessary conversions in tight loops.

3. **Pointer Access**: Direct pointer access is fastest, but only safe within the same tick.

4. **Handle Storage**: Handles are just integers (4 bytes), very efficient to store.

## Best Practices

1. ✅ **Store handles** for long-term entity references
2. ✅ **Use pointers** for immediate, same-tick operations
3. ✅ **Validate handles** before converting to pointers
4. ✅ **Use player slots** for player-specific functionality (familiar to CS community)
5. ✅ **Check pointer validity** even after handle validation
6. ❌ **Don't store pointers** across ticks
7. ❌ **Don't assume handles are always valid** - entities can be deleted
8. ❌ **Don't skip validation** in production code

## Common Invalid Handle Values

```csharp
// These constants indicate invalid/special handles:
const int INVALID_EHANDLE_INDEX = -1;
const int INVALID_ENTITY_INDEX = -1;
const int INVALID_PLAYER_SLOT = -1;

// Always check for these values:
if (entityHandle == INVALID_EHANDLE_INDEX)
{
    PrintToServer("Invalid handle\n");
    return;
}

if (playerSlot < 0 || playerSlot >= 64)
{
    PrintToServer("Invalid player slot\n");
    return;
}
```

## Troubleshooting

### Handle Becomes Invalid
**Problem**: Handle was valid, now returns false for `IsValidEntHandle()`
**Cause**: Entity was deleted from the game
**Solution**: Always validate before use, handle the invalid case gracefully

### Pointer Becomes Invalid Across Ticks
**Problem**: Pointer worked last tick, crashes this tick
**Cause**: Entity moved in memory or was deleted
**Solution**: Don't store pointers, use handles instead

### Player Slot Out of Range
**Problem**: Player slot is negative or > 63
**Cause**: Entity is not a player, or player disconnected
**Solution**: Validate player slot range before use

### Handle to Pointer Returns Null
**Problem**: `EntHandleToEntPointer()` returns null
**Cause**: Handle is invalid or entity was deleted
**Solution**: Check with `IsValidEntHandle()` first

## Summary

The handle system is fundamental to safe Source 2 modding:

- **Handles** provide safety and validity tracking
- **Pointers** provide performance for immediate use
- **Indices** provide simple identification
- **Player Slots** provide familiar player-specific operations

Use the conversion functions to move between representations as needed, always validate before use, and prefer handles for any long-term storage.

::callout{icon="i-lucide-lightbulb" color="amber"}
**Remember**: Most S2SDK functionality (schemas, entity methods, client operations) requires handles. Master the handle system to write safe, crash-free plugins!
::