---
title: Инструкции по сборке
description: Как собрать основную библиотеку (для интеграторов, а не для конечных пользователей).
icon: lucide:wrench
---

Это руководство содержит подробные инструкции по сборке Plugify на **Windows**, **Linux** и **macOS**. Оно также охватывает расширенные опции настройки и советы по устранению неполадок.

## Предварительные требования

Перед сборкой Plugify убедитесь, что у вас установлены следующие инструменты:

### Windows
- [Visual Studio 2022](https://visualstudio.microsoft.com/vs/) (с поддержкой C++ и CMake)
- [CMake](https://cmake.org/download/) (если не используется встроенный в Visual Studio CMake)
- [Git](https://git-scm.com/)

### Linux
- Основные инструменты для сборки (например, `gcc`, `g++`, `make`)
- [CMake](https://cmake.org/download/)
- [Ninja](https://ninja-build.org/) (опционально, для более быстрой сборки)
- [Git](https://git-scm.com/)

### macOS
- [Xcode Command Line Tools](https://developer.apple.com/xcode/)
- [CMake](https://cmake.org/download/)
- [Ninja](https://ninja-build.org/) (опционально, для более быстрой сборки)
- [Git](https://git-scm.com/)

## Клонирование репозитория

Для начала клонируйте репозиторий Plugify вместе с его подмодулями:

```
git clone https://github.com/untrustedmodders/plugify.git --recursive
cd plugify
```

## Сборка на Windows

### Использование Visual Studio 2022 с CMake

#### **Установите инструменты CMake**:  
   Убедитесь, что у вас [установлены инструменты CMake вместе с Visual Studio](https://learn.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio#installation).

::steps{level=4}
#### **Откройте проект**:
- Откройте [Visual Studio 2022](https://learn.microsoft.com/en-gb/visualstudio/install/install-visual-studio?view=vs-2022).
- Выберите `Файл > Открыть > CMake`.
- Перейдите в каталог репозитория и откройте файл `CMakeLists.txt`.

#### **Настройте и соберите**:
- Visual Studio автоматически настроит и сгенерирует необходимые файлы сборки.
- Выберите конфигурацию `Release` или `Debug`.
- Соберите проект, выбрав `Сборка > Собрать всё` в меню.
::

### Использование проекта Visual Studio 2022

::steps{level=4}
#### **Сгенерируйте файлы проекта**:
- Откройте командную строку и перейдите в каталог репозитория.
- Создайте каталог сборки и перейдите в него:
  ```
  mkdir build
  cd build
  ```
- Сгенерируйте файлы проекта Visual Studio с помощью CMake:
  ```
  cmake -G "Visual Studio 17 2022" ..
  ```

#### **Соберите решение**:
- Откройте сгенерированный файл `plugify.sln` в Visual Studio.
- Выберите конфигурацию `Release` или `Debug`.
- Соберите решение, выбрав `Сборка > Собрать решение` в меню.
::

### Использование MinGW

::steps{level=4}
#### **Сгенерируйте Makefiles**:
- Откройте командную строку и перейдите в каталог репозитория.
- Создайте каталог сборки и перейдите в него:
  ```
  mkdir build
  cd build
  ```
- Сгенерируйте Makefiles с помощью CMake:
  ```
  cmake -G "MinGW Makefiles" ..
  ```

#### **Соберите проект**:
- Используйте `mingw64-make` для сборки проекта:
  ```
  mingw64-make
  ```
::

### Использование командной строки

::steps{level=4}
#### **Сгенерируйте файлы сборки**:
- Откройте [командную строку разработчика Visual Studio](https://learn.microsoft.com/en-us/visualstudio/ide/reference/command-prompt-powershell?view=vs-2022) и перейдите в каталог репозитория.
- Создайте каталог сборки и перейдите в него:
  ```
  mkdir build
  cd build
  ```
- Сгенерируйте Makefiles с помощью CMake:
  ```
  cmake ..
  ```

#### **Соберите проект**:
- Используйте `cmake` для сборки проекта:
  ```
  cmake --build . --target plugify --preset Release -- /m
  ```
::

## Сборка на Linux

::steps{level=4}
#### **Установите зависимости**:
- Откройте терминал и установите необходимые зависимости:
  ```
  sudo apt-get install -y build-essential cmake ninja-build libcurl4-openssl-dev
  ```

#### **Сгенерируйте Makefiles**:
- Перейдите в каталог репозитория.
- Создайте каталог сборки и перейдите в него:
  ```
  mkdir build
  cd build
  ```
- Сгенерируйте Makefiles с помощью CMake:
  ```
  cmake ..
  ```

#### **Соберите проект**:
- Используйте `cmake` для сборки проекта:
  ```
  cmake --build . --target plugify --preset Release -- -j
  ```
::

## Сборка на macOS

::steps{level=4}
#### **Установите зависимости**:
- Откройте терминал и установите необходимые зависимости:
  ```
  brew install cmake ninja curl
  ```

#### **Сгенерируйте Makefiles**:
- Перейдите в каталог репозитория.
- Создайте каталог сборки и перейдите в него:
  ```
  mkdir build
  cd build
  ```
- Сгенерируйте Makefiles с помощью CMake:
  ```
  cmake ..
  ```

#### **Соберите проект**:
- Используйте `cmake` для сборки проекта:
  ```
  cmake --build . --target plugify --preset Release -- -j
  ```
::

## Сборка с помощью CLion

CLion можно использовать для сборки проекта на всех платформах (Windows, Linux, macOS):

::steps{level=4}
#### **Откройте проект**:
- Откройте CLion.
- Выберите `File > Open`.
- Перейдите в каталог репозитория и откройте файл `CMakeLists.txt`.

#### **Настройте и соберите**:
- CLion автоматически настроит и сгенерирует необходимые файлы сборки.
- Соберите проект, выбрав `Build > Build Project` в меню.
::

## Обновление

Чтобы обновить ваш локальный репозиторий до последней версии:

```
git fetch
git pull
git submodule update --remote --merge
```

Если сборка не удалась, попробуйте удалить каталог `build` и создать его заново, как описано выше. Обратите внимание, что процесс сборки не вносит никаких изменений за пределами каталога `build`.

## Типы сборки

Plugify поддерживает несколько типов сборки, которые можно указать с помощью переменной `CMAKE_BUILD_TYPE`. Тип сборки по умолчанию - `RelWithDebInfo`. Кроме того, Plugify предоставляет **пресеты** для сборок `Debug` и `Release`, чтобы упростить процесс.

### Доступные типы сборки
- **Debug**:
    - Включает отладочные символы и отключает оптимизации.
    - Идеально подходит для разработки и устранения неполадок.
    - Используйте этот пресет для локальных сборок, когда вам нужна подробная отладочная информация.

- **Release**:
    - Включает оптимизации и создает меньший, более быстрый бинарный файл.
    - Использует `RelWithDebInfo` для включения отладочных символов в локальных сборках.
    - Идеально подходит для производственных сборок, где важна производительность.

- **RelWithDebInfo**:
    - Включает оптимизации, но также содержит отладочные символы.
    - Это тип сборки по умолчанию и используется пресетом `Release`.

- **MinSizeRel**:
    - Включает оптимизации для получения наименьшего возможного размера бинарного файла.
    - Идеально подходит для сред, где важно использование дискового пространства или памяти.
    - Не включает отладочные символы.

### Использование пресетов
Plugify предоставляет два пресета для упрощения процесса сборки:

1. **Пресет Debug**:
    - Собирает проект с конфигурацией `Debug`.
    - Используйте этот пресет для локальной разработки и отладки.
    - Пример:
      ```
      cmake ..
      cmake --build . --preset Debug
      ```

2. **Пресет Release**:
    - Собирает проект с конфигурацией `Release`, которая использует `RelWithDebInfo` для включения отладочных символов в локальных сборках.
    - Используйте этот пресет для готовых к производству сборок.
    - Пример:
      ```
      cmake ..
      cmake --build . --preset Release
      ```

### Указание типов сборки вручную
Если вы предпочитаете указывать тип сборки вручную, вы можете использовать переменную `CMAKE_BUILD_TYPE`:

```
cmake -DCMAKE_BUILD_TYPE=Debug -G Ninja ..
cmake -DCMAKE_BUILD_TYPE=Release -G Ninja ..
cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -G Ninja ..
cmake -DCMAKE_BUILD_TYPE=MinSizeRel -G Ninja ..
```

## Настройка Plugify

Plugify предоставляет несколько опций CMake для настройки:

| Опция                                 | Описание                                                                                                                                         |
|---------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| `-DPLUGIFY_BUILD_TESTS=ON`            | Включить сборку тестов                                                                                                                           |
| `-DPLUGIFY_BUILD_DOCS=OFF`            | Включить сборку с документацией                                                                                                                  |
| `-DPLUGIFY_BUILD_OBJECT_LIB=OFF`      | Собрать Plugify как объектную библиотеку                                                                                                         |
| `-DPLUGIFY_BUILD_SHARED_LIB=ON`       | Собрать Plugify как разделяемую библиотеку                                                                                                       |
| `-DPLUGIFY_BUILD_SHARED_ASMJIT=OFF`   | Собрать AsmJit как разделяемую библиотеку                                                                                                        |
| `-DPLUGIFY_USE_EXTERNAL_ASMJIT=OFF`   | Использовать внешнюю библиотеку AsmJit                                                                                                           |
| `-DPLUGIFY_USE_EXTERNAL_GLAZE=OFF`    | Использовать внешнюю библиотеку Glaze                                                                                                            |
| `-PLUGIFY_USE_EXTERNAL_LIBSOLV=ON`    | Использовать внешнюю библиотеку LivSolv                                                                                                          |
| `-DPLUGIFY_USE_EXTERNAL_FMT=OFF`      | Использовать внешнюю библиотеку fmt                                                                                                              |
| `-DPLUGIFY_USE_LIBCPP=OFF`            | Использовать libc++ путем добавления флага `-stdlib=libc++`, если доступно                                                                       |
| `-DPLUGIFY_USE_STATIC_STDLIB=OFF`     | Включить статическую компоновку стандартной библиотеки для избежания проблем с ABI, добавляя флаги `-static-*`, если доступно                    |
| `-DPLUGIFY_USE_SANITIZER=OFF`         | Включить санитайзеры, добавляя флаги `-fsanitize=*`, если доступно                                                                               |
| `-PLUGIFY_SANITIZER_PATH=""`          | Путь к библиотекам санитайзерам.                                                                                                                 | 
| `-PLUGIFY_ENABLED_SANITIZERS=address` | Список имён санитайзеров, разделённых точкой с запятой. Например: `address;leak`. Поддерживаются санитайзеры: address, leak, undefined и thread. |
| `-DPLUGIFY_USE_CLANG_TIDY=OFF`        | Включить статический анализ с помощью clang-tidy                                                                                                 |
| `-DPLUGIFY_USE_ABI0=ON`               | Включить использование старого ABI C++, который был по умолчанию в версиях GCC до GCC 5                                                          |

## Тестирование сборки

Plugify включает в себя настраиваемую систему тестирования, предназначенную для проверки функциональности контейнеров (например, строк, вариантов, векторов), используемых в языковых модулях и плагинах. Эта система основана на двух ключевых компонентах:

- **`cross_call_worker`**: плагин, который реализует методы, вызываемые `cross_call_master`.
- **`cross_call_master`**: плагин, который вызывает методы из `cross_call_worker` и дает ему указание вызывать методы обратно.

Эти плагины используются для тестирования **маршалинга** (обмена данными между плагинами, написанными на разных языках) и обеспечения совместимости между языковыми модулями.

### Как это работает
1. **`cross_call_master`** вызывает методы из **`cross_call_worker`** другого языкового модуля.
2. **`cross_call_worker`** вызывает методы обратно в **`cross_call_master`**.
3. Это двунаправленное взаимодействие тестирует систему маршалинга и гарантирует, что данные правильно передаются между плагинами.

### Запуск тестов
Чтобы запустить тесты, вам нужно:
1. Собрать **тестовое приложение** (`plug`).
2. Собрать **языковые модули** и **плагины** (`cross_call_worker` и `cross_call_master`).
3. Настроить каталог `res` для включения необходимых плагинов и языковых модулей.

::steps{level=4}
#### Соберите тестовое приложение
Следуйте инструкциям по [установке](/essentials/installation), чтобы получить тестовое приложение `plug`.

:read-more{icon="lucide:link" to="/essentials/installation"}

#### Соберите языковые модули и плагины
1. Перейдите в каталог репозитория и создайте папку для сборки:
```
mkdir build
cd build
```
2. Сгенерируйте файлы сборки и включите тестирование:
```
cmake -DPLUGIFY_BUILD_TESTS=ON ..
```
3. Соберите языковые модули и плагины по отдельности. Например:
```
cmake --build . --target cross_call_worker
cmake --build . --target cross_call_master
```
**Примечание**: Убедитесь, что каждый плагин или языковой модуль собирается отдельно, чтобы избежать конфликтов и обеспечить правильную компиляцию.

#### Настройте каталог `res`
1. Создайте папку `res` в корневом каталоге репозитория:
```
mkdir ../res
```
2. Внутри папки `res` создайте две подпапки:
```
mkdir ../res/extensions
```
3. Скопируйте собранные плагины и языковые модули в папку `res`:
- Поместите `cross_call_worker` и `cross_call_master` в `res/extensions/`.
- Поместите языковые модули (например, `cpp-module`, `python-module`) в `res/extensions/`.

#### Запустите тесты
1. Перейдите в каталог `build` и запустите приложение `plug`:
   ```
   ./plug
   ```
2. Приложение загрузит плагины и языковые модули, и тесты запустятся автоматически.

::

### Пример рабочего процесса теста
1. **`cross_call_master`** вызывает метод из **`cross_call_worker`**, чтобы передать строку.
2. **`cross_call_worker`** обрабатывает строку и вызывает метод обратно в **`cross_call_master`**, чтобы вернуть измененную строку.
3. Тест проверяет, что строка была правильно передана и возвращена.

## Сборка документации

Документацию Plugify можно собрать локально с помощью Doxygen. Чтобы собрать документацию:

::steps
### **Установите Doxygen**:
- В Linux:
  ```bash
  sudo apt-get install doxygen
  ```
- В macOS:
  ```bash
  brew install doxygen
  ```
- В Windows:  
  Загрузите и установите Doxygen с [официального сайта](https://www.doxygen.nl/download.html).

### **Сгенерируйте документацию**:
- Перейдите в каталог репозитория и создайте папку для сборки:
  ```bash
  mkdir build
  cd build
  ```
- Включите сборку документации:
  ```bash
  cmake -DPLUGIFY_BUILD_DOCS=ON ..
  ```
- Соберите документацию:
  ```bash
  cmake --build . --target docs
  ```

### **Просмотрите документацию**:
- Откройте сгенерированную документацию в вашем браузере:
  ```bash
  your_favorite_browser docs/html/index.html
  ```
::