---
title: Экспорт функций
description: Руководство по экспорту функций из вашего плагина на C++ для использования другими языковыми модулями в Plugify.
icon: lucide:share-2
---

В экосистеме Plugify плагины на C++ могут экспортировать функции, чтобы сделать их доступными для других плагинов. Это руководство объясняет, как экспортировать функции в C++, и предоставляет примеры, которые помогут вам беспрепятственно интегрировать ваши плагины.

## **Базовое сопоставление типов**

В следующей таблице перечислены способы представления типов в C++ API:

| Тип C++                    | Псевдоним Plugify | Поддержка ссылок ? |
|----------------------------|-------------------|--------------------|
| void                       | void              | ❌                |
| bool                       | bool              | ✅                |
| char                       | char8             | ✅                |
| char16_t                   | char16            | ✅                |
| int8_t                     | int8              | ✅                |
| int16_t                    | int16             | ✅                |
| int32_t                    | int32             | ✅                |
| int64_t                    | int64             | ✅                |
| uint8_t                    | uint8             | ✅                |
| uint16_t                   | uint16            | ✅                |
| uint32_t                   | uint32            | ✅                |
| uint64_t                   | uint64            | ✅                |
| uintptr_t                  | ptr64             | ✅                |
| uintptr_t                  | ptr32             | ✅                |
| float                      | float             | ✅                |
| double                     | double            | ✅                |
| void*                      | function          | ❌                |
| plg::string                | string            | ✅                |
| plg::any                   | any               | ✅                |
| plg::vector\<bool\>        | bool\[\]          | ✅                |
| plg::vector\<char\>        | char8\[\]         | ✅                |
| plg::vector\<char16_t\>    | char16\[\]        | ✅                |
| plg::vector\<int8_t\>      | int8\[\]          | ✅                |
| plg::vector\<int16_t\>     | int16\[\]         | ✅                |
| plg::vector\<int32_t\>     | int32\[\]         | ✅                |
| plg::vector\<int64_t\>     | int64\[\]         | ✅                |
| plg::vector\<uint8_t\>     | uint8\[\]         | ✅                |
| plg::vector\<uint16_t\>    | uint16\[\]        | ✅                |
| plg::vector\<uint32_t\>    | uint32\[\]        | ✅                |
| plg::vector\<uint64_t\>    | uint64\[\]        | ✅                |
| plg::vector\<uintptr_t\>   | ptr64\[\]         | ✅                |
| plg::vector\<uintptr_t\>   | ptr32\[\]         | ✅                |
| plg::vector\<float\>       | float\[\]         | ✅                |
| plg::vector\<double\>      | double\[\]        | ✅                |
| plg::vector\<plg::string\> | string\[\]        | ✅                |
| plg::vector\<plg::any\>    | any\[\]           | ✅                |
| plg::vector\<plg::vec2\>   | vec2\[\]          | ✅                |
| plg::vector\<plg::vec3\>   | vec3\[\]          | ✅                |
| plg::vector\<plg::vec4\>   | vec4\[\]          | ✅                |
| plg::vector\<plg::mat4x4\> | mat4x4\[\]        | ✅                |
| plg::vec2                  | vec2              | ✅                |
| plg::vec3                  | vec3              | ✅                |
| plg::vec4                  | vec4              | ✅                |
| plg::mat4x4                | mat4x4            | ✅                |

## **Экспорт функций в C++**

Чтобы экспортировать функцию в плагине на C++, вам необходимо убедиться, что функция видна другим плагинам. Обычно это делается путем пометки функции макросом `PLUGIN_API`, который обеспечивает экспорт функции при компиляции плагина в виде динамически подключаемой библиотеки (DLL).

### **Ключевые моменты**
- **Статические функции**: Экспортируемые функции, как правило, должны быть `static`, чтобы избежать необходимости в экземпляре объекта для вызова.
- **С-компоновка**: Макрос `PLUGIN_API` не включает автоматически `extern "C"` для предотвращения искажения имен (name mangling). Мы должны убедиться, что функцию можно найти просто по имени, добавив `extern "C"`.
- **Типы параметров и возвращаемых значений**: Используйте нативные типы Plugify (например, `plg::string`, `plg::vector`) для бесшовной интеграции.

## **Генерация макроса PLUGIN_API**

Макрос `PLUGIN_API` генерируется с помощью CMake. Вот как вы можете настроить его в вашем файле `CMakeLists.txt`:

```cmake
include(GenerateExportHeader)
generate_export_header(${PROJECT_NAME}
    EXPORT_MACRO_NAME CPPLM_EXPORT
    EXPORT_FILE_NAME ${CMAKE_BINARY_DIR}/exports/module_export.h
)
target_include_directories(${PROJECT_NAME} PRIVATE ${CMAKE_BINARY_DIR}/exports)
```

Это генерирует заголовочный файл (`module_export.h`), который определяет макрос `PLUGIN_API`. Включите этот заголовочный файл в исходные файлы вашего плагина, чтобы помечать функции для экспорта.

## **Базовый пример**

Вот простой пример экспорта функции в плагине на C++:

### **Определение функции**
::code-group
```cpp [plugin.cpp]
#include <plugify/plugify.h>
#include "module_export.h" // Include the generated export header

extern "C" PLUGIN_API int32_t AddNumbers_Exported_Name(int32_t a, int32_t b) {
    return a + b;
}
```
::

### **Экспорт функции**
Когда плагин будет загружен, функция `AddNumbers` будет экспортирована и сможет вызываться другими плагинами.

## **Пример манифеста плагина**

Все экспортированные функции должны быть описаны в файле манифеста плагина в разделе `methods`. Вот пример манифеста для плагина, который экспортирует функцию `AddNumbers`:

::code-group
```json [plugin_name.pplugin]
{
  "name": "ExamplePlugin",
  "version": "1.0.0",
  "methods": [
    {
      "name": "AddNumbers",
      "funcName": "AddNumbers_Exported_Name",
      "paramTypes": [
        {
          "type": "int32",
          "name": "a"
        },
        {
          "type": "int32",
          "name": "b"
        }
      ],
      "retType": {
        "type": "int32"
      }
    }
  ]
}
```
::

## **Продвинутый пример: Экспорт сложных функций**

Вот пример экспорта функции со сложными типами параметров и возвращаемого значения:

### **Определение функции**
::code-group
```cpp [plugin.cpp]
#include <plugify/plugify.h>
#include "module_export.h"

extern "C" PLUGIN_API plg::vector<plg::string> ProcessData_Exported_Name(const plg::vector<double>& data, const plg::string& prefix) {
    plg::vector<plg::string> result;
    for (double value : data) {
        result.push_back(prefix + std::to_string(value));
    }
    return result;
}
```
::

### **Манифест плагина**
::code-group
```json [plugin_name.pplugin]
{
  "name": "ExamplePlugin",
  "version": "1.0.0",
  "methods": [
    {
      "name": "ProcessData",
      "funcName": "ProcessData_Exported_Name",
      "paramTypes": [
        {
          "type": "double[]",
          "name": "data"
        },
        {
          "type": "string",
          "name": "prefix"
        }
      ],
      "retType": {
        "type": "string[]"
      }
    }
  ]
}
```
::

## **Экспорт функций с параметрами по ссылке**

Plugify поддерживает ссылочные параметры (также известные как "out" или "ref" параметры), которые позволяют функциям изменять значения и возвращать их вызывающей стороне. В C++ ссылочные параметры объявляются с использованием символа `&`.

### **Определение функции с параметрами по ссылке**

::code-group
```cpp [plugin.cpp]
#include <plugify/plugin.hpp>

extern "C" PLUGIN_API void IncrementValue_Exported_Name(int32_t& value) {
    /**
     * Увеличивает целочисленное значение на 1.
     *
     * @param value Значение для увеличения (передается по ссылке).
     */
    value += 1;
}

extern "C" PLUGIN_API void Calculate_Exported_Name(int32_t a, int32_t b, int32_t& sum, int32_t& product) {
    /**
     * Вычисляет сумму и произведение двух чисел, возвращая оба значения через ссылки.
     *
     * @param a Первое число.
     * @param b Второе число.
     * @param sum Выходной параметр для суммы.
     * @param product Выходной параметр для произведения.
     */
    sum = a + b;
    product = a * b;
}
```
::

### **Манифест плагина с параметрами по ссылке**

В манифесте отметьте параметры, передаваемые по ссылке, используя `"ref": "ref"`:

::code-group
```json [plugin_name.pplugin]
{
  "name": "ExampleCppPlugin",
  "version": "1.0.0",
  "methods": [
    {
      "name": "IncrementValue",
      "funcName": "IncrementValue_Exported_Name",
      "paramTypes": [
        {
          "type": "int32",
          "name": "value",
          "ref": "ref"
        }
      ],
      "retType": {
        "type": "void"
      }
    },
    {
      "name": "Calculate",
      "funcName": "Calculate_Exported_Name",
      "paramTypes": [
        {
          "type": "int32",
          "name": "a"
        },
        {
          "type": "int32",
          "name": "b"
        },
        {
          "type": "int32",
          "name": "sum",
          "ref": "ref"
        },
        {
          "type": "int32",
          "name": "product",
          "ref": "ref"
        }
      ],
      "retType": {
        "type": "void"
      }
    }
  ]
}
```
::

### **Поддержка параметров по ссылке**

Параметры по ссылке работают с большинством типов Plugify, как показано в столбце "Поддержка ссылок" таблицы сопоставления типов. Следующие типы **не** поддерживают ссылки:
- `void` (не может быть передан по ссылке)
- `function` (типы обратных вызовов)

Все остальные типы, включая примитивы, строки, векторы и структуры, поддерживают параметры по ссылке.

## **Обработка обратных вызовов (callbacks)**

Plugify позволяет экспортировать функции, которые принимают обратные вызовы в качестве параметров. Вот пример:

### **Определение функции**
```cpp
#include <plugify/plugify.h>
#include "module_export.h"

using CallbackFunction = plg::string(*)(int32_t, const plg::string&);

extern "C" PLUGIN_API void ExecuteWithCallback_Exported_Name(int32_t value, const plg::string& input, CallbackFunction callback) {
    plg::string result = callback(value, input);
    // Process the result
}
```

### **Манифест плагина**
::code-group
```json [plugin_name.pplugin]
{
  "name": "ExamplePlugin",
  "version": "1.0.0",
  "methods": [
    {
      "name": "ExecuteWithCallback",
      "funcName": "ExecuteWithCallback_Exported_Name",
      "paramTypes": [
        {
          "type": "int32",
          "name": "value"
        },
        {
          "type": "string",
          "name": "input"
        },
        {
          "type": "function",
          "name": "callback",
          "prototype": {
            "name": "ExampleCallback",
            "funcName": "ExampleCallback_Exported_Name",
            "paramTypes": [
              {
                "type": "int32",
                "name": "value"
              },
              {
                "type": "string",
                "name": "input"
              }
            ],
            "retType": {
              "type": "string"
            }
          }
        }
      ],
      "retType": {
        "type": "void"
      }
    }
  ]
}
```
::

## **Автоматизация генерации манифеста**

::callout{icon="i-lucide-sparkles" color="blue"}
**Новинка:** Теперь вы можете автоматизировать генерацию раздела `methods` в манифесте вашего плагина с помощью clang-doc и парсера на Python!
::

Вместо ручного написания JSON-манифеста для каждой экспортируемой функции, вы можете использовать автоматизированные инструменты для извлечения сигнатур функций, типов, описаний параметров и даже определений перечислений непосредственно из вашего исходного кода C++.

### **Преимущества автоматической генерации**

1. **Не требуется ручное написание JSON**: Сигнатуры функций автоматически извлекаются из вашего кода
2. **Полная информация о типах**: Структуры перечислений и typedef функций включаются автоматически
3. **Интеграция документации**: Комментарии Doxygen парсятся и включаются в манифест
4. **Меньше ошибок**: Устраняются опечатки и несоответствия типов между кодом и манифестом
5. **Простое обслуживание**: Изменения в сигнатурах функций автоматически отражаются

### **Настройка: Добавление генерации документации в CMake**

Добавьте следующее в ваш `CMakeLists.txt` для генерации документации и JSON-манифеста:

```cmake
# Найти clang-doc (обычно поставляется с установкой LLVM/Clang)
find_program(CLANG_DOC clang-doc)

if(CLANG_DOC)
    # Генерация YAML-документации из ваших экспортируемых функций
    add_custom_target(docs
        COMMAND ${CLANG_DOC}
            --executor=all-TUs
            -p ${CMAKE_CURRENT_BINARY_DIR}
            --output=${CMAKE_CURRENT_SOURCE_DIR}/docs
            --extra-arg=-Wno-error
            --format=yaml
            ${CMAKE_SOURCE_DIR}/src/export/*.cpp  # Путь к вашим экспортируемым функциям
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
        COMMENT "Generating documentation with clang-doc"
    )

    # Опционально: Автоматическое преобразование YAML в JSON после генерации документации
    find_package(Python3 COMPONENTS Interpreter)
    if(Python3_FOUND)
        add_custom_command(TARGET docs POST_BUILD
            COMMAND ${Python3_EXECUTABLE}
                    ${CMAKE_SOURCE_DIR}/parser/parser.py
                    ${CMAKE_SOURCE_DIR}/docs/index.yaml
                    ${CMAKE_SOURCE_DIR}/exported_methods.json
            COMMENT "Parsing documentation to JSON"
        )
    endif()
endif()
```

### **Использование парсера**

::steps{level=4}
#### **Установка парсера**

Скачайте `parser.py` и поместите его в ваш проект (например, в директорию `tools/`).

Установите зависимости:
```bash
pip install pyyaml
```

:read-more{icon="lucide:github" to="https://github.com/untrustedmodders/plugify-module-cpp/tree/main/parser" title="Репозиторий GitHub"}

#### **Документируйте ваши функции**

Добавьте комментарии Doxygen к вашим экспортируемым функциям:

```cpp
/**
 * @brief Создает консольную команду как административную команду.
 * Если команда не существует, она создается. Когда эта команда вызывается,
 * права доступа игрока автоматически проверяются перед разрешением продолжения.
 *
 * @param name Имя консольной команды.
 * @param adminFlags Флаги администратора, указывающие, какой уровень администратора может использовать эту команду.
 * @param description Краткое описание того, что делает команда.
 * @param flags Флаги команды, определяющие поведение команды.
 * @param callback Функция обратного вызова, которая вызывается при выполнении команды.
 * @param mode Был ли хук в режиме post (после обработки) или в режиме pre (до обработки).
 * @return Логическое значение, указывающее, была ли команда успешно добавлена.
 */
extern "C" PLUGIN_API bool AddAdminCommand(
    const plg::string& name,
    int64_t adminFlags,
    const plg::string& description,
    ConVarFlag flags,
    CommandCallback callback,
    HookMode mode
);
```

#### **Документируйте перечисления и typedef**

Документируйте ваши перечисления и typedef функций:

```cpp
/**
 * @brief Перечисление, представляющее тип обратного вызова.
 */
enum class HookMode : uint8_t {
    /** Обратный вызов будет выполнен перед оригинальной функцией */
    Pre = 0,
    /** Обратный вызов будет выполнен после оригинальной функции */
    Post = 1
};

/**
 * @brief Обрабатывает выполнение команды, вызванной вызывающей стороной.
 * Эта функция обрабатывает команду, интерпретирует ее контекст и обрабатывает любые предоставленные аргументы.
 */
using CommandCallback = ResultType (*)(int32_t caller, CommandCallingContext context, const plg::vector<plg::string>& arguments);
```

#### **Генерация документации**

Соберите цель документации:
```bash
cmake --build . --target docs
```

Это генерирует `docs/index.yaml` со всей информацией о ваших функциях.

#### **Преобразование в JSON**

Запустите парсер для преобразования YAML в формат манифеста:
```bash
python3 parser/parser.py docs/index.yaml exported_methods.json
```

Или с фильтрацией:
```bash
# Только функции из файлов, начинающихся с "commands"
python3 parser/parser.py docs/index.yaml exported_methods.json --file-prefix "commands"

# Только функции с "Admin" в имени
python3 parser/parser.py docs/index.yaml exported_methods.json --name-filter "Admin"
```

#### **Использование в манифесте**

Скопируйте сгенерированный массив `methods` из `exported_methods.json` в манифест вашего плагина:

```json
{
  "name": "ExamplePlugin",
  "version": "1.0.0",
  "methods": [
    // Вставьте содержимое из exported_methods.json сюда
  ]
}
```
::

### **Продвинутое: Структуры перечислений**

Парсер автоматически включает полные определения перечислений, когда параметр использует тип перечисления:

**Сгенерированный вывод:**
```json
{
  "name": "mode",
  "type": "uint8",
  "description": "Был ли хук в режиме post или в режиме pre.",
  "enum": {
    "name": "HookMode",
    "description": "Перечисление, представляющее тип обратного вызова.",
    "values": [
      {
        "name": "Pre",
        "value": 0,
        "description": "Обратный вызов будет выполнен перед оригинальной функцией"
      },
      {
        "name": "Post",
        "value": 1,
        "description": "Обратный вызов будет выполнен после оригинальной функции"
      }
    ]
  }
}
```

### **Продвинутое: Typedef функций**

Typedef указателей на функции автоматически парсятся в полные прототипы:

**Сгенерированный вывод:**
```json
{
  "name": "callback",
  "type": "function",
  "description": "Функция обратного вызова, которая вызывается при выполнении команды.",
  "prototype": {
    "name": "CommandCallback",
    "funcName": "CommandCallback",
    "description": "Обрабатывает выполнение команды, вызванной вызывающей стороной.",
    "paramTypes": [
      {
        "name": "param1",
        "type": "int32"
      },
      {
        "name": "param2",
        "type": "int32",
        "enum": {
          "name": "CommandCallingContext",
          "values": [...]
        }
      },
      {
        "name": "param3",
        "type": "string[]"
      }
    ],
    "retType": {
      "type": "int32",
      "enum": {
        "name": "ResultType",
        "values": [...]
      }
    }
  }
}
```

::callout{icon="i-lucide-info" color="amber"}
**Примечание:** Имена параметров typedef функций генерируются автоматически как `param1`, `param2` и т.д. Вы можете захотеть настроить их в манифесте для лучшей документации.
::

## **Рекомендации**

1. **Используйте `PLUGIN_API`**: Всегда используйте макрос `PLUGIN_API` для пометки функций для экспорта.
2. **Следуйте соглашениям о типах**: Придерживайтесь соглашений о типах Plugify для параметров и возвращаемых значений.
3. **Документируйте ваши функции**: Четко документируйте назначение, параметры и возвращаемые значения экспортируемых функций.
4. **Тщательно тестируйте**: Тестируйте ваши экспортированные функции, чтобы убедиться, что они работают как ожидалось при вызове из других плагинов.
5. **Обновляйте манифест**: Всегда описывайте экспортированные функции в манифесте плагина в разделе `methods`.

## **Заключение**

Экспорт функций в плагинах на C++ прост, если вы следуете соглашениям и лучшим практикам Plugify. Используя макрос `PLUGIN_API`, придерживаясь соглашений о типах и описывая функции в манифесте плагина, вы можете создавать надежные и совместимые плагины. Для более сложных сценариев использования, таких как обработка обратных вызовов или возврат объектов C++, используйте методы, изложенные в этом руководстве.