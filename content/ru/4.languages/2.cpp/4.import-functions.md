---
title: Импорт функций
description: Узнайте, как импортировать функции из других плагинов, написанных на разных языках, и использовать их в своем собственном.
icon: lucide:arrow-down
---

Чтобы использовать функции из другого плагина в вашем плагине на C++, вам необходимо сгенерировать специфичные для языка заголовочные файлы. Эти заголовочные файлы предоставляют необходимые обертки для вызова функций, экспортируемых другими плагинами. Это руководство объясняет, как генерировать эти заголовочные файлы и как использовать их в вашем плагине на C++.

## **Генерация заголовочных файлов**

Plugify предоставляет унифицированный инструмент-генератор для автоматической генерации заголовочных файлов для импорта функций из других плагинов. Эти заголовочные файлы включают функции-обертки, которые обрабатывают вызовы функций и передачу параметров.

### **Шаги по генерации привязок**

::steps{level=4}
#### **Использование онлайн-генератора**:
Посетите [инструмент plugify-gen](https://gen.plugify.net/) для генерации привязок через удобный веб-интерфейс. Просто загрузите файл манифеста плагина (`.pplugin`) и выберите C++ в качестве целевого языка, чтобы сгенерировать соответствующий модуль.

#### **Использование инструмента командной строки**:
Вы также можете скачать и использовать инструмент-генератор локально из [репозитория plugify-gen](https://github.com/untrustedmodders/plugify-gen/).

**Пример использования**:
```bash
plugify-gen -manifest ./plugins/plugin_from_another_language/plugin_from_another_language.pplugin -output ./output/ -lang cpp
```

#### **Интегрируйте сгенерированный модуль**:
- Инструмент сгенерирует папку модуля (например, `plugin_from_another_language/`) в указанной выходной директории.
- Скопируйте всю сгенерированную папку модуля в исходную директорию вашего проекта.
- Включите заголовочные файлы модуля в вашу систему сборки (CMakeLists.txt, Makefile и т.д.).
- Добавьте директорию модуля в пути включения.
::

## **Интеграция с проектом**

После генерации модуля интегрируйте его в ваш проект на C++:

::steps
### **Скопируйте модуль в проект**
Скопируйте сгенерированную папку модуля в исходную директорию вашего проекта:
```bash
cp -r ./output/plugin_from_another_language ./my_plugin/src/
```

### **Обновите CMakeLists.txt**
Добавьте директорию модуля в пути включения:
```cmake
target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/plugin_from_another_language
)
```

### **Включите в исходные файлы**
Включите сгенерированные заголовочные файлы в ваши исходные файлы:
```cpp
#include "plugin_from_another_language/plugin_from_another_language.hpp"
```
::

## **Использование сгенерированных функций-оберток**

Сгенерированный модуль содержит функции-обертки, которые позволяют вам вызывать функции из другого плагина. Эти обертки обрабатывают поиск адреса функции и передачу параметров.

### **Пример сгенерированного заголовочного файла**
Вот пример сгенерированного заголовочного файла для плагина с именем `plugin_from_another_language`:

::code-group
```cpp [plugin_from_another_language.hpp]
#pragma once

#include <cstdint>
#include <plg/plugin.hpp>
#include <plg/any.hpp>

// Generated from plugin_from_another_language.pplugin by https://github.com/untrustedmodders/plugify-gen

namespace plugin_from_another_language {
    using _ParamCallback = void (*)(int32_t, float, double, const plg::vec4&, const plg::vector<int64_t>&, char, const plg::string&, char16_t, int16_t);
    extern _ParamCallback __plugin_from_another_language_ParamCallback = nullptr;
        
    inline void ParamCallback(int32_t a, float b, double c, const plg::vec4& d, const plg::vector<int64_t>& e, char f, const plg::string& g, char16_t h, int16_t k) {
        __plugin_from_another_language_ParamCallback(a, b, c, d, e, f, g, h, k);
    }
} // namespace plugin_from_another_language
```
::

### **Как это работает**
- Функция-обертка (`ParamCallback`) получает адрес экспортированной функции с помощью `plg::GetMethodPtr` или `plg::GetMethodPtr2`.
- Делегат `__plugin_from_another_language_ParamCallback` устанавливается языковым модулем во время загрузки плагина.
- Функция-обертка напрямую передает параметры в экспортированную функцию, используя соглашение о вызовах C.

## **Пример: Использование сгенерированного заголовочного файла**

Вот как вы можете использовать сгенерированный заголовочный файл в вашем плагине на C++:

::code-group
```cpp [plugin.cpp]
#include "plugin_from_another_language.hpp" // Include the generated header

void MyPluginFunction() {
    // Call the exported function from the other plugin
    plugin_from_another_language::ParamCallback(
        42,                // int32_t a
        3.14f,             // float b
        2.718,             // double c
        {1.0f, 2.0f, 3.0f, 4.0f}, // plg::vec4 d
        {100, 200},        // plg::vector<int64_t> e
        'x',               // char f
        "Hello, Plugify!", // plg::string g
        u'✓',              // char16_t h
        10                 // int16_t k
    );
}
```
::

## **Когда необходима генерация заголовочных файлов?**

Генерация заголовочных файлов необходима при импорте функций из плагинов, написанных на статически типизированных языках, таких как C++ или C#. Без этих заголовочных файлов компилятор не сможет ссылаться на экспортированные функции. Для динамически типизированных языков, таких как Python, генерация заголовочных файлов не требуется, поскольку привязка методов происходит во время выполнения.

## **Рекомендации**

1. **Используйте инструмент-генератор**: Всегда используйте инструмент-генератор Plugify (онлайн или командной строки) для генерации заголовочных файлов для импортируемых функций.
2. **Включайте сгенерированные заголовочные файлы**: Включайте сгенерированные заголовочные файлы в исходные файлы вашего плагина для доступа к экспортированным функциям.
3. **Тщательно тестируйте**: Тестируйте импортированные функции, чтобы убедиться, что они работают как ожидалось.
4. **Документируйте зависимости**: Четко документируйте плагины и функции, от которых зависит ваш плагин.

## **Заключение**

Импорт функций из другого плагина в C++ прост, если вы используете инструмент-генератор Plugify для генерации необходимых заголовочных файлов. Эти заголовочные файлы предоставляют функции-обертки, которые обрабатывают поиск адреса функции и передачу параметров, что упрощает интеграцию функциональности из других плагинов. Следуя шагам и лучшим практикам, изложенным в этом руководстве, вы можете создавать надежные и совместимые плагины в экосистеме Plugify.