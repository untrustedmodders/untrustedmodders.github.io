---
title: Импорт функций
description: Узнайте, как импортировать функции из других плагинов, написанных на разных языках, и использовать их в своем собственном.
icon: lucide:arrow-down
---

Чтобы использовать функции из другого плагина в вашем плагине на C++, вам необходимо сгенерировать специфичные для языка заголовочные файлы. Эти заголовочные файлы предоставляют необходимые обертки для вызова функций, экспортируемых другими плагинами. Это руководство объясняет, как генерировать эти заголовочные файлы и как использовать их в вашем плагине на C++.

## **Генерация заголовочных файлов**

Plugify предоставляет скрипт Python (`generator.py`) для автоматической генерации заголовочных файлов для импорта функций из других плагинов. Эти заголовочные файлы включают функции-обертки, которые обрабатывают вызовы функций и передачу параметров.

### **Шаги по генерации заголовочных файлов**

::steps{level=4}
#### **Найдите скрипт-генератор**:
- Скрипт `generator.py` находится в папке `generator` языкового модуля C++.

:read-more{icon="lucide:link" to="https://github.com/untrustedmodders/plugify-module-cpp/tree/main/generator" title="Репозиторий на GitHub"}

#### **Запустите скрипт-генератор**:
- Откройте терминал или командную строку и перейдите в папку, содержащую `generator.py`.
- Запустите скрипт со следующей командой:
  ```bash
  python generator.py "path_to_plugin.pplugin" "output_folder"
  ```
    - `path_to_plugin.pplugin`: Путь к файлу манифеста плагина (`.pplugin`), из которого вы хотите импортировать функции.
    - `output_folder`: Каталог, в который будет сохранен сгенерированный заголовочный файл.

   **Пример**:
   ```bash
   python generator.py ./plugins/plugin_from_another_language/plugin_from_another_language.pplugin ./output/
   ```

#### **Включите сгенерированный заголовочный файл**:
- Скрипт сгенерирует заголовочный файл (например, `plugin_from_another_language.hpp`) в указанной папке вывода.
- Включите этот заголовочный файл в исходные файлы вашего плагина на C++, чтобы использовать экспортированные функции.
::

## **Использование сгенерированных функций-оберток**

Сгенерированный заголовочный файл содержит функции-обертки, которые позволяют вам вызывать функции из другого плагина. Эти обертки обрабатывают поиск адреса функции и передачу параметров.

### **Пример сгенерированного заголовочного файла**
Вот пример сгенерированного заголовочного файла для плагина с именем `plugin_from_another_language`:

::code-group
```cpp [plugin_from_another_language.hpp]
#pragma once

#include <plugify/cpp_plugin.hpp>
#include <plugify/any.hpp>
#include <cstdint>

// Generated from plugin_from_another_language.pplugin by https://github.com/untrustedmodders/plugify-module-cpp/blob/main/generator/generator.py

namespace plugin_from_another_language {
    inline void ParamCallback(int32_t a, float b, double c, const plg::vec4& d, const plg::vector<int64_t>& e, char f, const plg::string& g, char16_t h, int16_t k) {
        using ParamCallbackFn = void (*)(int32_t, float, double, const plg::vec4&, const plg::vector<int64_t>&, char, const plg::string&, char16_t, int16_t);
        static ParamCallbackFn __func = nullptr;
        if (__func == nullptr) plg::GetMethodPtr2("plugin_from_another_language.ParamCallback", reinterpret_cast<void**>(&__func));
        __func(a, b, c, d, e, f, g, h, k);
    }
} // namespace plugin_from_another_language
```
::

### **Как это работает**
- Функция-обертка (`ParamCallback`) получает адрес экспортированной функции с помощью `plg::GetMethodPtr` или `plg::GetMethodPtr2`.
- Адрес функции сохраняется в статической переменной (`__func`), чтобы избежать повторных поисков.
- Функция-обертка напрямую передает параметры в экспортированную функцию, используя соглашение о вызовах C++.

## **Пример: Использование сгенерированного заголовочного файла**

Вот как вы можете использовать сгенерированный заголовочный файл в вашем плагине на C++:

::code-group
```cpp [plugin.cpp]
#include "plugin_from_another_language.hpp" // Include the generated header

void MyPluginFunction() {
    // Call the exported function from the other plugin
    plugin_from_another_language::ParamCallback(
        42,                // int32_t a
        3.14f,             // float b
        2.718,             // double c
        {1.0f, 2.0f, 3.0f, 4.0f}, // plg::vec4 d
        {100, 200},        // plg::vector<int64_t> e
        'x',               // char f
        "Hello, Plugify!", // plg::string g
        u'✓',              // char16_t h
        10                 // int16_t k
    );
}
```
::

## **Когда необходима генерация заголовочных файлов?**

Генерация заголовочных файлов необходима при импорте функций из плагинов, написанных на статически типизированных языках, таких как C++ или C#. Без этих заголовочных файлов компилятор не сможет ссылаться на экспортированные функции. Для динамически типизированных языков, таких как Python, генерация заголовочных файлов не требуется, поскольку привязка методов происходит во время выполнения.

## **Рекомендации**

1. **Используйте скрипт-генератор**: Всегда используйте скрипт `generator.py` для генерации заголовочных файлов для импортируемых функций.
2. **Включайте сгенерированные заголовочные файлы**: Включайте сгенерированные заголовочные файлы в исходные файлы вашего плагина для доступа к экспортированным функциям.
3. **Тщательно тестируйте**: Тестируйте импортированные функции, чтобы убедиться, что они работают как ожидалось.
4. **Документируйте зависимости**: Четко документируйте плагины и функции, от которых зависит ваш плагин.

## **Заключение**

Импорт функций из другого плагина в C++ прост, если вы используете скрипт `generator.py` для генерации необходимых заголовочных файлов. Эти заголовочные файлы предоставляют функции-обертки, которые обрабатывают поиск адреса функции и передачу параметров, что упрощает интеграцию функциональности из других плагинов. Следуя шагам и лучшим практикам, изложенным в этом руководстве, вы можете создавать надежные и совместимые плагины в экосистеме Plugify.