---
title: Экспорт функций
description: Руководство по экспорту функций из вашего плагина для использования другими языковыми модулями в Plugify.
icon: lucide:share-2
---

В экосистеме Plugify плагины на C# могут экспортировать функции, чтобы сделать их доступными для других плагинов. Это руководство объясняет, как определять и экспортировать функции в C#, и предоставляет примеры, которые помогут вам беспрепятственно интегрировать ваши плагины.

## **Базовое сопоставление типов**

В следующей таблице перечислены способы представления типов в C# API:

| Тип C++                    | Тип C#         | Псевдоним Plugify | Поддержка Ref? |
|----------------------------|----------------|---------------|----------------|
| void                       | void           | void          | ❌             |
| bool                       | Bool8          | bool          | ✅             |
| char                       | Char8          | char8         | ✅             |
| char16_t                   | Char16         | char16        | ✅             |
| int8_t                     | sbyte          | int8          | ✅             |
| int16_t                    | short          | int16         | ✅             |
| int32_t                    | int            | int32         | ✅             |
| int64_t                    | long           | int64         | ✅             |
| uint8_t                    | byte           | uint8         | ✅             |
| uint16_t                   | ushort         | uint16        | ✅             |
| uint32_t                   | uint           | uint32        | ✅             |
| uint64_t                   | ulong          | uint64        | ✅             |
| uintptr_t                  | nint           | ptr64         | ✅             |
| uintptr_t                  | nint           | ptr32         | ✅             |
| float                      | float          | float         | ✅             |
| double                     | double         | double        | ✅             |
| void*                      | Delegate       | function      | ❌             |
| plg::string                | string         | string        | ✅             |
| plg::any                   | object         | any           | ✅             |
| plg::vector\<bool\>        | Bool8\[\]      | bool\[\]      | ✅             |
| plg::vector\<char\>        | Char8\[\]      | char8\[\]     | ✅             |
| plg::vector\<char16_t\>    | Char16\[\]     | char16\[\]    | ✅             |
| plg::vector\<int8_t\>      | sbyte\[\]      | int8\[\]      | ✅             |
| plg::vector\<int16_t\>     | short\[\]      | int16\[\]     | ✅             |
| plg::vector\<int32_t\>     | int\[\]        | int32\[\]     | ✅             |
| plg::vector\<int64_t\>     | long\[\]       | int64\[\]     | ✅             |
| plg::vector\<uint8_t\>     | byte\[\]       | uint8\[\]     | ✅             |
| plg::vector\<uint16_t\>    | ushort\[\]     | uint16\[\]    | ✅             |
| plg::vector\<uint32_t\>    | uint\[\]       | uint32\[\]    | ✅             |
| plg::vector\<uint64_t\>    | ulong\[\]      | uint64\[\]    | ✅             |
| plg::vector\<uintptr_t\>   | nint\[\]       | ptr64\[\]     | ✅             |
| plg::vector\<uintptr_t\>   | nint\[\]       | ptr32\[\]     | ✅             |
| plg::vector\<float\>       | float\[\]      | float\[\]     | ✅             |
| plg::vector\<double\>      | double\[\]     | double\[\]    | ✅             |
| plg::vector\<plg::string\> | string\[\]     | string\[\]    | ✅             |
| plg::vector\<plg::any\>    | object\[\]     | any\[\]       | ✅             |
| plg::vector\<plg::vec2\>   | Vector2\[\]    | vec2\[\]      | ✅             |
| plg::vector\<plg::vec3\>   | Vector3\[\]    | vec3\[\]      | ✅             |
| plg::vector\<plg::vec4\>   | Vector4\[\]    | vec4\[\]      | ✅             |
| plg::vector\<plg::mat4x4\> | Matrix4x4\[\]  | mat4x4\[\]    | ✅             |
| plg::vec2                  | Vector2        | vec2          | ✅             |
| plg::vec3                  | Vector3        | vec3          | ✅             |
| plg::vec4                  | Vector4        | vec4          | ✅             |
| plg::mat4x4                | Matrix4x4      | mat4x4        | ✅             |

## **Экспорт функций в C#**

Экспорт функций в C# прост, поскольку C# - это статически типизированный язык. Вам нужно определить функцию и указать ее в манифесте плагина. Языковой модуль C# в Plugify позаботится обо всем остальном.

## **Простой пример**

Вот простой пример экспорта функции в плагине на C#:

### **Определение функции**
::code-group
```csharp [plugin.cs]
namespace ExampleCSharpPlugin
{
    public static class ExportedFunctions
    {
        /// <summary>
        /// Складывает два целых числа.
        /// </summary>
        /// <param name="a">Первое целое число.</param>
        /// <param name="b">Второе целое число.</param>
        /// <returns>Сумма a и b.</returns>
        public static int AddNumbers_Exported(int a, int b)
        {
            return a + b;
        }
    }
}
```
::

### **Манифест плагина**
Чтобы экспортировать функцию, опишите ее в манифесте плагина в разделе `methods`:
::code-group
```json [plugin_name.pplugin]
{
  "name": "ExampleCSharpPlugin",
  "version": "1.0.0",
  "methods": [
    {
      "name": "AddNumbers",
      "funcName": "ExampleCSharpPlugin.ExportedFunctions.AddNumbers_Exported",
      "paramTypes": [
        {
          "type": "int32",
          "name": "a"
        },
        {
          "type": "int32",
          "name": "b"
        }
      ],
      "retType": {
        "type": "int32"
      }
    }
  ]
}
```
::

## **Сложный пример: Экспорт сложных функций**

Вот пример экспорта функции со сложными типами параметров и возвращаемого значения:

### **Определение функции**
::code-group
```csharp [plugin.cs]
namespace ExampleCSharpPlugin
{
    public static class ExportedFunctions
    {
        /// <summary>
        /// Обрабатывает массив чисел double и возвращает массив строк.
        /// </summary>
        /// <param name="data">Массив значений double.</param>
        /// <param name="prefix">Префикс для добавления к каждому значению.</param>
        /// <returns>Массив отформатированных строк.</returns>
        public static string[] ProcessData_Exported(double[] data, string prefix)
        {
            return data.Select(value => $"{prefix}{value}").ToArray();
        }
    }
}
```
::

### **Манифест плагина**
::code-group
```json [plugin_name.pplugin]
{
  "name": "ExampleCSharpPlugin",
  "version": "1.0.0",
  "methods": [
    {
      "name": "ProcessData",
      "funcName": "ExampleCSharpPlugin.ExportedFunctions.ProcessData_Exported",
      "paramTypes": [
        {
          "type": "double[]",
          "name": "data"
        },
        {
          "type": "string",
          "name": "prefix"
        }
      ],
      "retType": {
        "type": "string[]"
      }
    }
  ]
}
```
::

## **Экспорт функций с параметрами по ссылке**

Plugify поддерживает ссылочные параметры (также известные как "out" или "ref" параметры), которые позволяют функциям изменять значения и возвращать их вызывающей стороне. В C# ссылочные параметры объявляются с использованием ключевого слова `ref`.

### **Определение функции с параметрами по ссылке**

::code-group
```csharp [plugin.cs]
namespace ExampleCSharpPlugin
{
    public static class ExportedFunctions
    {
        /// <summary>
        /// Увеличивает целочисленное значение на 1.
        /// </summary>
        /// <param name="value">Значение для увеличения (передается по ссылке).</param>
        public static void IncrementValue_Exported(ref int value)
        {
            value += 1;
        }

        /// <summary>
        /// Вычисляет сумму и произведение двух чисел, возвращая оба значения через ссылки.
        /// </summary>
        /// <param name="a">Первое число.</param>
        /// <param name="b">Второе число.</param>
        /// <param name="sum">Выходной параметр для суммы.</param>
        /// <param name="product">Выходной параметр для произведения.</param>
        public static void Calculate_Exported(int a, int b, ref int sum, ref int product)
        {
            sum = a + b;
            product = a * b;
        }
    }
}
```
::

### **Манифест плагина с параметрами по ссылке**

В манифесте отметьте параметры, передаваемые по ссылке, используя `"ref": "ref"`:

::code-group
```json [plugin_name.pplugin]
{
  "name": "ExampleCSharpPlugin",
  "version": "1.0.0",
  "methods": [
    {
      "name": "IncrementValue",
      "funcName": "ExampleCSharpPlugin.ExportedFunctions.IncrementValue_Exported",
      "paramTypes": [
        {
          "type": "int32",
          "name": "value",
          "ref": "ref"
        }
      ],
      "retType": {
        "type": "void"
      }
    },
    {
      "name": "Calculate",
      "funcName": "ExampleCSharpPlugin.ExportedFunctions.Calculate_Exported",
      "paramTypes": [
        {
          "type": "int32",
          "name": "a"
        },
        {
          "type": "int32",
          "name": "b"
        },
        {
          "type": "int32",
          "name": "sum",
          "ref": "ref"
        },
        {
          "type": "int32",
          "name": "product",
          "ref": "ref"
        }
      ],
      "retType": {
        "type": "void"
      }
    }
  ]
}
```
::

### **Поддержка параметров по ссылке**

Параметры по ссылке работают с большинством типов Plugify, как показано в столбце "Поддержка ссылок" таблицы сопоставления типов. Следующие типы **не** поддерживают ссылки:
- `void` (не может быть передан по ссылке)
- `function` (типы обратных вызовов/делегатов)

Все остальные типы, включая примитивы, строки, массивы и структуры, поддерживают параметры по ссылке.

## **Обработка обратных вызовов (Callbacks)**

Plugify позволяет экспортировать функции, которые принимают обратные вызовы в качестве параметров. Вот пример:

### **Определение функции**
::code-group
```csharp [plugin.cs]
namespace ExampleCSharpPlugin
{
    public delegate string ExampleCallback(int a, string b);

    public static class ExportedFunctions
    {
        /// <summary>
        /// Выполняет функцию обратного вызова с предоставленными параметрами.
        /// </summary>
        /// <param name="value">Целочисленное значение.</param>
        /// <param name="inputStr">Входная строка.</param>
        /// <param name="callback">Функция обратного вызова для выполнения.</param>
        public static void ExecuteWithCallback_Exported(int value, string inputStr, ExampleCallback callback)
        {
            string result = callback(value, inputStr);
            Console.WriteLine($"Результат обратного вызова: {result}");
        }
    }
}
```
::

### **Манифест плагина**
::code-group
```json [plugin_name.pplugin]
{
  "name": "ExampleCSharpPlugin",
  "version": "1.0.0",
  "methods": [
    {
      "name": "ExecuteWithCallback",
      "funcName": "ExampleCSharpPlugin.ExportedFunctions.ExecuteWithCallback_Exported",
      "paramTypes": [
        {
          "type": "int32",
          "name": "value"
        },
        {
          "type": "string",
          "name": "inputStr"
        },
        {
          "type": "function",
          "name": "callback",
          "prototype": {
            "name": "ExampleCallback",
            "funcName": "ExampleCallback_Exported",
            "paramTypes": [
              {
                "type": "int32",
                "name": "value"
              },
              {
                "type": "string",
                "name": "inputStr"
              }
            ],
            "retType": {
              "type": "string"
            }
          }
        }
      ],
      "retType": {
        "type": "void"
      }
    }
  ]
}
```
::

## **Автоматизация генерации манифеста**

::callout{icon="i-lucide-sparkles" color="blue"}
**Новое:** Теперь вы можете автоматизировать генерацию раздела `methods` в манифесте вашего плагина с помощью генератора источников Roslyn - Plugify.Generator!
::

Вместо ручного написания JSON манифеста для каждой экспортируемой функции, вы можете использовать NuGet-пакет `Plugify.Generator` для автоматической генерации записей манифеста для функций, помеченных атрибутом `[NativeExport]`.

### **Преимущества автоматической генерации**

1. **Нет ручного написания JSON**: Сигнатуры функций автоматически извлекаются из вашего кода
2. **Полная информация о типах**: Типы параметров и возвращаемых значений автоматически сопоставляются
3. **Меньше ошибок**: Устраняются опечатки и несоответствия типов между кодом и манифестом
4. **Простота обслуживания**: Изменения в сигнатурах функций автоматически отражаются в манифесте
5. **Генерация во время сборки**: Манифест генерируется во время компиляции, всегда оставаясь синхронизированным

### **Настройка: Установка Plugify.Generator**

Добавьте NuGet-пакет `Plugify.Generator` в ваш проект плагина на C#:

```bash
dotnet add package Plugify.Generator
```

Или добавьте его напрямую в ваш файл `.csproj`:

```xml
<ItemGroup>
  <PackageReference Include="Plugify" Version="*" />
  <PackageReference Include="Plugify.Generator" Version="*" />
</ItemGroup>
```

Пакет `Plugify` предоставляет атрибут `[NativeExport]`, а `Plugify.Generator` - это генератор источников Roslyn, который обрабатывает эти атрибуты во время компиляции.

### **Использование атрибута NativeExport**

Пометьте ваши экспортируемые функции атрибутом `[NativeExport("ИмяФункции")]`:

::code-group
```csharp [plugin.cs]
using Plugify;

namespace ExampleCSharpPlugin
{
    public static class ExportedFunctions
    {
        /// <summary>
        /// Складывает два целых числа.
        /// </summary>
        /// <param name="a">Первое целое число.</param>
        /// <param name="b">Второе целое число.</param>
        /// <returns>Сумма a и b.</returns>
        [NativeExport("AddNumbers")]
        public static int AddNumbers_Exported(int a, int b)
        {
            return a + b;
        }

        /// <summary>
        /// Обрабатывает массив чисел double и возвращает массив строк.
        /// </summary>
        /// <param name="data">Массив значений double.</param>
        /// <param name="prefix">Префикс для добавления к каждому значению.</param>
        /// <returns>Массив отформатированных строк.</returns>
        [NativeExport("ProcessData")]
        public static string[] ProcessData_Exported(double[] data, string prefix)
        {
            return data.Select(value => $"{prefix}{value}").ToArray();
        }
    }
}
```
::

### **Как это работает**

1. **Во время компиляции**: Генератор источников Roslyn сканирует ваш код на наличие методов, помеченных `[NativeExport]`
2. **Сопоставление типов**: Он автоматически сопоставляет типы C# с типами Plugify (например, `int` → `int32`, `string[]` → `string[]`)
3. **Генерация манифеста**: JSON-файл, содержащий массив `methods`, генерируется в выходных данных сборки
4. **Интеграция**: Скопируйте сгенерированные записи манифеста в ваш файл `.pplugin`

### **Сгенерированный результат**

При сборке вашего проекта генератор создает файл (например, `ExampleCSharpPlugin.methods.json`), содержащий:

```json
[
  {
    "name": "AddNumbers",
    "funcName": "ExampleCSharpPlugin.ExportedFunctions.AddNumbers_Exported",
    "paramTypes": [
      {
        "type": "int32",
        "name": "a"
      },
      {
        "type": "int32",
        "name": "b"
      }
    ],
    "retType": {
      "type": "int32"
    }
  },
  {
    "name": "ProcessData",
    "funcName": "ExampleCSharpPlugin.ExportedFunctions.ProcessData_Exported",
    "paramTypes": [
      {
        "type": "double[]",
        "name": "data"
      },
      {
        "type": "string",
        "name": "prefix"
      }
    ],
    "retType": {
      "type": "string[]"
    }
  }
]
```

Просто скопируйте этот массив в раздел `methods` вашего манифеста плагина.

### **Продвинутое использование: Работа с делегатами**

Генератор также поддерживает типы делегатов для параметров обратного вызова:

::code-group
```csharp [plugin.cs]
using Plugify;

namespace ExampleCSharpPlugin
{
    public delegate string ExampleCallback(int a, string b);

    public static class ExportedFunctions
    {
        /// <summary>
        /// Выполняет функцию обратного вызова с предоставленными параметрами.
        /// </summary>
        /// <param name="value">Целочисленное значение.</param>
        /// <param name="inputStr">Входная строка.</param>
        /// <param name="callback">Функция обратного вызова для выполнения.</param>
        [NativeExport("ExecuteWithCallback")]
        public static void ExecuteWithCallback_Exported(int value, string inputStr, ExampleCallback callback)
        {
            string result = callback(value, inputStr);
            Console.WriteLine($"Результат обратного вызова: {result}");
        }
    }
}
```
::

Генератор автоматически создаст полную структуру прототипа функции:

```json
{
  "name": "ExecuteWithCallback",
  "funcName": "ExampleCSharpPlugin.ExportedFunctions.ExecuteWithCallback_Exported",
  "paramTypes": [
    {
      "type": "int32",
      "name": "value"
    },
    {
      "type": "string",
      "name": "inputStr"
    },
    {
      "type": "function",
      "name": "callback",
      "prototype": {
        "name": "ExampleCallback",
        "funcName": "ExampleCallback_Exported",
        "paramTypes": [
          {
            "type": "int32",
            "name": "a"
          },
          {
            "type": "string",
            "name": "b"
          }
        ],
        "retType": {
          "type": "string"
        }
      }
    }
  ],
  "retType": {
    "type": "void"
  }
}
```

::callout{icon="i-lucide-info" color="amber"}
**Примечание:** Генератор источников использует рефлексию и анализаторы Roslyn для извлечения информации о типах во время компиляции. Убедитесь, что ваши типы делегатов определены в той же сборке или в ссылочных сборках.
::

## **Лучшие практики**

1. **Определяйте функции четко**: Убедитесь, что ваши функции хорошо документированы и просты для понимания.
2. **Соблюдайте соглашения о типах**: Придерживайтесь соглашений о типах Plugify для параметров и возвращаемых значений.
3. **Используйте XML-документацию**: Добавляйте комментарии XML-документации (`/// <summary>`, `/// <param>`, `/// <returns>`) для предоставления описаний в сгенерированном манифесте.
4. **Используйте атрибут NativeExport**: По возможности используйте атрибут `[NativeExport]` с Plugify.Generator для автоматизации генерации манифеста.
5. **Тестируйте тщательно**: Тестируйте ваши экспортированные функции, чтобы убедиться, что они работают так, как ожидается, при вызове из других плагинов.
6. **Поддерживайте манифесты в актуальном состоянии**: Если используете автоматическую генерацию, перегенерируйте манифест после внесения изменений в сигнатуры функций.

## **Заключение**

Экспорт функций в плагинах на C# прост и понятен. Определяя свои функции и описывая их в манифесте плагина, вы можете создавать надежные и совместимые плагины. С новым генератором источников Roslyn - Plugify.Generator вы можете автоматизировать генерацию манифеста, просто помечая функции атрибутом `[NativeExport]`, что снижает ручные усилия и поддерживает ваш манифест синхронизированным с кодом. Для более сложных случаев, таких как обработка обратных вызовов, используйте методы, описанные в этом руководстве.