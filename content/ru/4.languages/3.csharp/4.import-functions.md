---
title: Импорт функций
description: Узнайте, как импортировать функции из других плагинов, написанных на разных языках, и использовать их в своем собственном.
icon: lucide:arrow-down
---

Чтобы использовать функции из другого плагина в вашем плагине на C#, вам необходимо сгенерировать специфичные для языка заголовочные файлы. Эти заголовочные файлы предоставляют необходимые обертки для вызова функций, экспортируемых другими плагинами. Это руководство объясняет, как сгенерировать эти файлы и как их использовать в вашем плагине на C#.

## **Генерация заголовочных файлов**

Plugify предоставляет скрипт на Python (`generator.py`) для автоматической генерации заголовочных файлов для импорта функций из других плагинов. Эти файлы включают функции-обертки, которые обрабатывают вызовы функций и передачу параметров.

### **Шаги по генерации заголовочных файлов**

::steps{level=4}
#### **Найдите скрипт генератора**:
- Скрипт `generator.py` находится в папке `generator` языкового модуля C#.

:read-more{icon="lucide:link" to="https://github.com/untrustedmodders/plugify-module-dotnet/tree/main/generator" title="Репозиторий на GitHub"}

#### **Запустите скрипт генератора**:
- Откройте терминал или командную строку и перейдите в папку, содержащую `generator.py`.
- Запустите скрипт с помощью следующей команды:
   ```bash
   python generator.py "путь_к_плагину.pplugin" "выходная_папка"
   ```
     - `путь_к_плагину.pplugin`: Путь к файлу манифеста плагина (`.pplugin`), из которого вы хотите импортировать функции.
     - `выходная_папка`: Каталог, в котором будет сохранен сгенерированный заголовочный файл.

**Пример**:
```bash
python generator.py ./plugins/MyPlugin/MyPlugin.pplugin ./output/
```

#### **Подключите сгенерированный заголовочный файл**:
- Скрипт сгенерирует заголовочный файл (например, `MyPlugin.cs`) в указанной выходной папке.
- Подключите этот файл в исходные файлы вашего плагина на C#, чтобы использовать экспортированные функции.
::

## **Использование сгенерированных функций-оберток**

Сгенерированный заголовочный файл содержит функции-обертки, которые позволяют вызывать функции из другого плагина. Эти обертки обрабатывают поиск адреса функции и передачу параметров.

### **Пример сгенерированного заголовочного файла**
Вот пример сгенерированного заголовочного файла для плагина с именем `plugin_from_another_language`:

::code-group
```csharp [plugin_from_another_language.cs]
using System;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Plugify;

// Сгенерировано из plugin_from_another_language.pplugin с помощью https://github.com/untrustedmodders/plugify-module-dotnet/blob/main/generator/generator.py

namespace plugin_from_another_language {
    internal static unsafe class plugin_from_another_language {
        internal static delegate*<int, float, double, Vector4, long[], Char8, string, Char16, short, void> ParamCallback = &___ParamCallback; // Используйте это для вызова функции
        internal static delegate* unmanaged[Cdecl]<int, float, double, Vector4*, Vector192*, Char8, String192*, Char16, short, void> __ParamCallback; // Внутренний вызов (оригинальная функция)
        private static void ___ParamCallback(int a, float b, double c, Vector4 d, long[] e, Char8 f, string g, Char16 h, short k) {
            var __e = NativeMethods.ConstructVectorInt64(e, e.Length);
            var __g = NativeMethods.ConstructString(g);

            try {
                __ParamCallback(a, b, c, &d, &__e, f, &__g, h, k);
            }
            finally {
                // Выполнить очистку.
                NativeMethods.DestroyVectorInt64(&__e);
                NativeMethods.DestroyString(&__g);
            }
        }
    }
}
```
::

### **Как это работает**
- Функция-обертка (`___ParamCallback`) обрабатывает маршалинг параметров и очистку.
- Делегат `__ParamCallback` устанавливается языковым модулем во время загрузки плагина.
- Делегат `ParamCallback` - это публичная функция, которую вы можете вызывать в своем коде на C#.

## **Пример: Использование сгенерированного заголовочного файла**

Вот как вы можете использовать сгенерированный заголовочный файл в вашем плагине на C#:

::code-group
```csharp [plugin.cs]
using plugin_from_another_language;

public class MyPlugin {
    public void MyFunction() {
        // Вызов экспортированной функции из другого плагина
        plugin_from_another_language.plugin_from_another_language.ParamCallback(
            42,                // int a
            3.14f,             // float b
            2.718,             // double c
            new Vector4(1, 2, 3, 4), // Vector4 d
            new long[] { 100, 200 }, // long[] e
            new Char8('x'),    // Char8 f
            "Hello, Plugify!", // string g
            new Char16('✓'),   // Char16 h
            10                 // short k
        );
    }
}
```
::

## **Когда необходима генерация заголовочных файлов?**

Генерация заголовочных файлов необходима при импорте функций из плагинов, написанных на статически типизированных языках, таких как C++ или C#. Без этих файлов компилятор не сможет ссылаться на экспортированные функции. Для динамически типизированных языков, таких как Python, генерация заголовочных файлов не требуется, поскольку привязка методов происходит во время выполнения.

## **Лучшие практики**

1.  **Используйте скрипт генератора**: Всегда используйте скрипт `generator.py` для генерации заголовочных файлов для импортируемых функций.
2.  **Подключайте сгенерированные файлы**: Подключайте сгенерированные заголовочные файлы в исходные файлы вашего плагина для доступа к экспортированным функциям.
3.  **Тестируйте тщательно**: Тестируйте импортированные функции, чтобы убедиться, что они работают так, как ожидается.
4.  **Документируйте зависимости**: Четко документируйте плагины и функции, от которых зависит ваш плагин.

## **Заключение**

Импорт функций из другого плагина в C# прост, если вы используете скрипт `generator.py` для генерации необходимых заголовочных файлов. Эти файлы предоставляют функции-обертки, которые обрабатывают поиск адреса функции и передачу параметров, что упрощает интеграцию функциональности из других плагинов. Следуя шагам и лучшим практикам, изложенным в этом руководстве, вы можете создавать надежные и совместимые плагины в экосистеме Plugify.