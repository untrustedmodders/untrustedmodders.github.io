---
title: Импорт функций
description: Узнайте, как импортировать функции из других плагинов, написанных на разных языках, и использовать их в своем собственном.
icon: lucide:arrow-down
---

Чтобы использовать функции из другого плагина в вашем плагине на C#, вам необходимо сгенерировать специфичные для языка заголовочные файлы. Эти заголовочные файлы предоставляют необходимые обертки для вызова функций, экспортируемых другими плагинами. Это руководство объясняет, как сгенерировать эти файлы и как их использовать в вашем плагине на C#.

## **Генерация заголовочных файлов**

Plugify предоставляет унифицированный инструмент-генератор для автоматической генерации заголовочных файлов для импорта функций из других плагинов. Эти файлы включают функции-обертки, которые обрабатывают вызовы функций и передачу параметров.

### **Шаги по генерации привязок**

::steps{level=4}
#### **Использование онлайн-генератора**:
Посетите [инструмент plugify-gen](https://gen.plugify.net/) для генерации привязок через удобный веб-интерфейс. Просто загрузите файл манифеста плагина (`.pplugin`) и выберите C# в качестве целевого языка, чтобы сгенерировать соответствующий модуль C#.

#### **Использование инструмента командной строки**:
Вы также можете скачать и использовать инструмент-генератор локально из [репозитория plugify-gen](https://github.com/untrustedmodders/plugify-gen/).

**Пример использования**:
```bash
plugify-gen -manifest ./plugins/MyPlugin/MyPlugin.pplugin -output ./output/ -lang csharp
```

#### **Интегрируйте сгенерированный модуль**:
- Инструмент сгенерирует папку модуля (например, `plugin_from_another_language/`) в указанной выходной директории.
- Скопируйте всю сгенерированную папку модуля в директорию вашего проекта.
- Добавьте сгенерированные файлы `.cs` в ваш проект C#.
::

## **Интеграция с проектом**

После генерации модуля интегрируйте его в ваш проект на C#:

::steps
### **Скопируйте модуль в проект**
Скопируйте сгенерированную папку модуля в директорию вашего проекта:
```bash
cp -r ./output/plugin_from_another_language ./MyPlugin/
```

### **Добавьте в .csproj**
Добавьте сгенерированные файлы в ваш `.csproj`:
```xml
<ItemGroup>
    <Compile Include="plugin_from_another_language\**\*.cs" />
</ItemGroup>
```

Или добавьте каждый файл вручную:
```xml
<ItemGroup>
    <Compile Include="plugin_from_another_language\plugin_from_another_language.cs" />
</ItemGroup>
```

### **Используйте пространство имен**
Используйте сгенерированное пространство имен в ваших файлах C#:
```csharp
using plugin_from_another_language;
```
::

## **Использование сгенерированных функций-оберток**

Сгенерированный модуль содержит функции-обертки, которые позволяют вызывать функции из другого плагина. Эти обертки обрабатывают поиск адреса функции и передачу параметров.

### **Пример сгенерированного заголовочного файла**
Вот пример сгенерированного заголовочного файла для плагина с именем `plugin_from_another_language`:

::code-group
```csharp [plugin_from_another_language.cs]
using System;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Plugify;

// Сгенерировано из plugin_from_another_language.pplugin с помощью https://github.com/untrustedmodders/plugify-gen

namespace plugin_from_another_language {
    internal static unsafe class plugin_from_another_language {
        internal static delegate*<int, float, double, Vector4, long[], Char8, string, Char16, short, void> ParamCallback = &___ParamCallback; // Используйте это для вызова функции
        internal static delegate* unmanaged[Cdecl]<int, float, double, Vector4*, Vector192*, Char8, String192*, Char16, short, void> __ParamCallback; // Внутренний вызов (оригинальная функция)
        private static void ___ParamCallback(int a, float b, double c, Vector4 d, long[] e, Char8 f, string g, Char16 h, short k) {
            var __e = NativeMethods.ConstructVectorInt64(e, e.Length);
            var __g = NativeMethods.ConstructString(g);

            try {
                __ParamCallback(a, b, c, &d, &__e, f, &__g, h, k);
            }
            finally {
                // Выполнить очистку.
                NativeMethods.DestroyVectorInt64(&__e);
                NativeMethods.DestroyString(&__g);
            }
        }
    }
}
```
::

### **Как это работает**
- Функция-обертка (`___ParamCallback`) обрабатывает маршалинг параметров и очистку.
- Делегат `__ParamCallback` устанавливается языковым модулем во время загрузки плагина.
- Делегат `ParamCallback` - это публичная функция, которую вы можете вызывать в своем коде на C#.

## **Пример: Использование сгенерированного заголовочного файла**

Вот как вы можете использовать сгенерированный заголовочный файл в вашем плагине на C#:

::code-group
```csharp [plugin.cs]
using plugin_from_another_language;

public class MyPlugin {
    public void MyFunction() {
        // Вызов экспортированной функции из другого плагина
        plugin_from_another_language.plugin_from_another_language.ParamCallback(
            42,                // int a
            3.14f,             // float b
            2.718,             // double c
            new Vector4(1, 2, 3, 4), // Vector4 d
            new long[] { 100, 200 }, // long[] e
            new Char8('x'),    // Char8 f
            "Hello, Plugify!", // string g
            new Char16('✓'),   // Char16 h
            10                 // short k
        );
    }
}
```
::

## **Когда необходима генерация заголовочных файлов?**

Генерация заголовочных файлов необходима при импорте функций из плагинов, написанных на статически типизированных языках, таких как C++ или C#. Без этих файлов компилятор не сможет ссылаться на экспортированные функции. Для динамически типизированных языков, таких как Python, генерация заголовочных файлов не требуется, поскольку привязка методов происходит во время выполнения.

## **Лучшие практики**

1.  **Используйте инструмент-генератор**: Всегда используйте инструмент-генератор Plugify (онлайн или командной строки) для генерации заголовочных файлов для импортируемых функций.
2.  **Подключайте сгенерированные файлы**: Подключайте сгенерированные заголовочные файлы в исходные файлы вашего плагина для доступа к экспортированным функциям.
3.  **Тестируйте тщательно**: Тестируйте импортированные функции, чтобы убедиться, что они работают так, как ожидается.
4.  **Документируйте зависимости**: Четко документируйте плагины и функции, от которых зависит ваш плагин.

## **Заключение**

Импорт функций из другого плагина в C# прост, если вы используете инструмент-генератор Plugify для генерации необходимых заголовочных файлов. Эти файлы предоставляют функции-обертки, которые обрабатывают поиск адреса функции и передачу параметров, что упрощает интеграцию функциональности из других плагинов. Следуя шагам и лучшим практикам, изложенным в этом руководстве, вы можете создавать надежные и совместимые плагины в экосистеме Plugify.