---
title: Импорт функций
description: Узнайте, как импортировать функции из других плагинов, написанных на разных языках, и использовать их в своем собственном.
icon: lucide:arrow-down
---

Чтобы использовать функции из другого плагина в вашем плагине на Go, вам необходимо сгенерировать специфичные для языка заголовочные файлы. Эти заголовочные файлы предоставляют необходимые обертки для вызова функций, экспортируемых другими плагинами. Это руководство объясняет, как сгенерировать эти заголовочные файлы и как их использовать в вашем плагине на Go.

## **Генерация заголовочных файлов**

Plugify предоставляет скрипт на Python (`generator.py`) для автоматической генерации заголовочных файлов для импорта функций из других плагинов. Эти заголовочные файлы включают функции-обертки, которые обрабатывают вызовы функций и передачу параметров.

### **Шаги по генерации заголовочных файлов**

::steps{level=4}
#### **Найдите скрипт генератора**:
- Скрипт `generator.py` находится в папке `generator` языкового модуля Go.

:read-more{icon="lucide:link" to="https://github.com/untrustedmodders/plugify-module-golang/tree/main/generator" title="Репозиторий на GitHub"}

#### **Запустите скрипт генератора**:
- Откройте терминал или командную строку и перейдите в папку, содержащую `generator.py`.
- Запустите скрипт с помощью следующей команды:
   ```bash
   python generator.py "путь_к_плагину.pplugin" "выходная_папка"
   ```
     - `путь_к_плагину.pplugin`: Путь к файлу манифеста плагина (`.pplugin`), из которого вы хотите импортировать функции.
     - `выходная_папка`: Каталог, в котором будет сохранен сгенерированный заголовочный файл.

**Пример**:
```bash
python generator.py ./plugins/MyPlugin/MyPlugin.pplugin ./output/
```

#### **Подключите сгенерированный заголовочный файл**:
- Скрипт сгенерирует заголовочный файл (например, `plugin_from_another_language.go`) в указанной выходной папке.
- Подключите этот заголовочный файл в исходные файлы вашего плагина на Go, чтобы использовать экспортированные функции.
::

## **Использование сгенерированных функций-оберток**

Сгенерированный заголовочный файл содержит функции-обертки, которые позволяют вызывать функции из другого плагина. Эти обертки обрабатывают поиск адреса функции и передачу параметров.

### **Пример сгенерированного заголовочного файла**
Вот пример сгенерированного заголовочного файла для плагина с именем `plugin_from_another_language`:

::code-group
```go [plugin_from_another_language.go]
package plugin_from_another_language

// Сгенерировано из plugin_from_another_language.pplugin с помощью https://github.com/untrustedmodders/plugify-module-golang/blob/main/generator/generator.py

// #include "plugin_from_another_language.h"
import "C"
import "unsafe"

func ParamCallback(a int32, b float32, c float64, d Vector4, e []int64, f int8, g string, h uint16, k int16) {
    C_a := C.int32_t(a)
    C_b := C.float(b)
    C_c := C.double(c)
    C_d := *(*C.Vector4)(unsafe.Pointer(&d))
    var A_e unsafe.Pointer
    S_e := len(e)
    if S_e > 0 {
        A_e = unsafe.Pointer(&e[0])
    } else {
        A_e = nil
    }
    C_e := C.Plugify_ConstructVector(A_e, C.ptrdiff_t(S_e), C.INT64)
    C_f := C.char(f)
    C_g := C.Plugify_ConstructString(g)
    C_h := C.uint16_t(h)
    C_k := C.int16_t(k)

    C.ParamCallback(C_a, C_b, C_c, &C_d, &C_e, C_f, &C_g, C_h, C_k)

    C.Plugify_DestroyVector(&C_e, C.INT64)
    C.Plugify_DestroyString(&C_g)
}
```
::

::code-group
```c [plugin_from_another_language.h]
typedef void (*ParamCallbackFn)(int32_t, float, double, Vector4*, Vector*, char, String*, uint16_t, int16_t);
static void ParamCallback(int32_t a, float b, double c, Vector4* d, Vector* e, char f, String* g, uint16_t h, int16_t k) {
	static ParamCallbackFn __func = NULL;
	if (__func == NULL) Plugify_GetMethodPtr2("cross_call_master.ParamCallback", (void**)&__func);
	__func(a, b, c, d, e, f, g, h, k);
}
```
::

### **Как это работает**
- Функция-обертка (`ParamCallback`) обрабатывает маршалинг параметров и очистку.
- Функция `C.ParamCallback` устанавливается языковым модулем во время загрузки плагина.
- Функция-обертка гарантирует, что типы Go правильно преобразуются в типы C и наоборот.

## **Пример: Использование сгенерированного заголовочного файла**

Вот как вы можете использовать сгенерированный заголовочный файл в вашем плагине на Go:

::code-group
```go [plugin.go]
package main

import (
    "plugin_from_another_language"
    "fmt"
)

func main() {
    // Вызов экспортированной функции из другого плагина
    plugin_from_another_language.ParamCallback(
        42,                // int32 a
        3.14,              // float32 b
        2.718,             // float64 c
        plugin_from_another_language.Vector4{1, 2, 3, 4}, // Vector4 d
        []int64{100, 200}, // []int64 e
        'x',               // int8 f
        "Hello, Plugify!", // string g
        123,               // uint16 h
        10,                // int16 k
    )
}
```
::

## **Когда необходима генерация заголовочных файлов?**

Генерация заголовочных файлов необходима при импорте функций из плагинов, написанных на статически типизированных языках, таких как C++ или Go. Без этих заголовочных файлов компилятор не сможет ссылаться на экспортированные функции. Для динамически типизированных языков, таких как Python, генерация заголовочных файлов не требуется, поскольку связывание методов происходит во время выполнения.

## **Лучшие практики**

1. **Используйте скрипт генератора**: Всегда используйте скрипт `generator.py` для генерации заголовочных файлов для импортируемых функций.
2. **Подключайте сгенерированные заголовочные файлы**: Подключайте сгенерированные заголовочные файлы в исходные файлы вашего плагина для доступа к экспортированным функциям.
3. **Тестируйте тщательно**: Тестируйте импортированные функции, чтобы убедиться, что они работают так, как ожидается.
4. **Документируйте зависимости**: Четко документируйте плагины и функции, от которых зависит ваш плагин.

## **Заключение**

Импорт функций из другого плагина в Go прост, если вы используете скрипт `generator.py` для генерации необходимых заголовочных файлов. Эти заголовочные файлы предоставляют функции-обертки, которые обрабатывают поиск адреса функции и передачу параметров, что упрощает интеграцию функциональности из других плагинов. Следуя шагам и лучшим практикам, изложенным в этом руководстве, вы можете создавать надежные и совместимые плагины в экосистеме Plugify.