---
title: Импорт функций
description: Узнайте, как импортировать функции из других плагинов, написанных на разных языках, и использовать их в своем собственном.
icon: lucide:arrow-down
---

Чтобы использовать функции из другого плагина в вашем плагине на Go, вам необходимо сгенерировать специфичные для языка заголовочные файлы. Эти заголовочные файлы предоставляют необходимые обертки для вызова функций, экспортируемых другими плагинами. Это руководство объясняет, как сгенерировать эти заголовочные файлы и как их использовать в вашем плагине на Go.

## **Генерация заголовочных файлов**

Plugify предоставляет унифицированный инструмент-генератор для автоматической генерации заголовочных файлов для импорта функций из других плагинов. Эти заголовочные файлы включают функции-обертки, которые обрабатывают вызовы функций и передачу параметров.

### **Шаги по генерации привязок**

::steps{level=4}
#### **Использование онлайн-генератора**:
Посетите [инструмент plugify-gen](https://gen.plugify.net/) для генерации привязок через удобный веб-интерфейс. Просто загрузите файл манифеста плагина (`.pplugin`) и выберите Go в качестве целевого языка, чтобы сгенерировать соответствующий модуль Go.

#### **Использование инструмента командной строки**:
Вы также можете скачать и использовать инструмент-генератор локально из [репозитория plugify-gen](https://github.com/untrustedmodders/plugify-gen/).

**Пример использования**:
```bash
plugify-gen -manifest ./plugins/MyPlugin/MyPlugin.pplugin -output ./output/ -lang go
```

#### **Интегрируйте сгенерированный модуль**:
- Инструмент сгенерирует папку модуля (например, `plugin_from_another_language/`) в указанной выходной директории.
- Скопируйте всю сгенерированную папку модуля в директорию вашего проекта.
- Модуль можно импортировать как локальный пакет Go в вашем плагине.
::

## **Интеграция с проектом**

После генерации модуля интегрируйте его в ваш проект на Go:

::steps
### **Скопируйте модуль в проект**
Скопируйте сгенерированную папку модуля в директорию вашего проекта:
```bash
cp -r ./output/plugin_from_another_language ./my_plugin/
```

### **Импортируйте модуль**
Импортируйте сгенерированный пакет в ваши файлы Go:
```go
import (
    "my_plugin/plugin_from_another_language"
)
```

### **Обновите go.mod (при необходимости)**
Если используете модули Go, убедитесь, что локальный модуль доступен:
```go
module my_plugin

go 1.21

replace my_plugin/plugin_from_another_language => ./plugin_from_another_language
```
::

## **Использование сгенерированных функций-оберток**

Сгенерированный модуль содержит функции-обертки, которые позволяют вызывать функции из другого плагина. Эти обертки обрабатывают поиск адреса функции и передачу параметров.

### **Пример сгенерированного заголовочного файла**
Вот пример сгенерированного заголовочного файла для плагина с именем `plugin_from_another_language`:

::code-group
```go [plugin_from_another_language.go]
package plugin_from_another_language

// Сгенерировано из plugin_from_another_language.pplugin с помощью https://github.com/untrustedmodders/plugify-gen

// #include "plugin_from_another_language.h"
import "C"
import "unsafe"

func ParamCallback(a int32, b float32, c float64, d Vector4, e []int64, f int8, g string, h uint16, k int16) {
    C_a := C.int32_t(a)
    C_b := C.float(b)
    C_c := C.double(c)
    C_d := *(*C.Vector4)(unsafe.Pointer(&d))
    var A_e unsafe.Pointer
    S_e := len(e)
    if S_e > 0 {
        A_e = unsafe.Pointer(&e[0])
    } else {
        A_e = nil
    }
    C_e := C.Plugify_ConstructVector(A_e, C.ptrdiff_t(S_e), C.INT64)
    C_f := C.char(f)
    C_g := C.Plugify_ConstructString(g)
    C_h := C.uint16_t(h)
    C_k := C.int16_t(k)

    C.ParamCallback(C_a, C_b, C_c, &C_d, &C_e, C_f, &C_g, C_h, C_k)

    C.Plugify_DestroyVector(&C_e, C.INT64)
    C.Plugify_DestroyString(&C_g)
}
```
::

::code-group
```c [plugin_from_another_language.h]
extern void (*__plugin_from_another_language_ParamCallback)(int32_t, float, double, Vector4*, Vector*, char, String*, uint16_t, int16_t);

static void ParamCallback(int32_t a, float b, double c, Vector4* d, Vector* e, char f, String* g, uint16_t h, int16_t k) {
	__plugin_from_another_language_ParamCallback(a, b, c, d, e, f, g, h, k);
}
```
::

### **Как это работает**
- Функция-обертка (`ParamCallback`) обрабатывает маршалинг параметров и очистку.
- Функция `____plugin_from_another_language_ParamCallback` устанавливается языковым модулем во время загрузки плагина.
- Функция-обертка гарантирует, что типы Go правильно преобразуются в типы C и наоборот.

## **Пример: Использование сгенерированного заголовочного файла**

Вот как вы можете использовать сгенерированный заголовочный файл в вашем плагине на Go:

::code-group
```go [plugin.go]
package main

import (
    "plugin_from_another_language"
    "fmt"
)

func main() {
    // Вызов экспортированной функции из другого плагина
    plugin_from_another_language.ParamCallback(
        42,                // int32 a
        3.14,              // float32 b
        2.718,             // float64 c
        plugin_from_another_language.Vector4{1, 2, 3, 4}, // Vector4 d
        []int64{100, 200}, // []int64 e
        'x',               // int8 f
        "Hello, Plugify!", // string g
        123,               // uint16 h
        10,                // int16 k
    )
}
```
::

## **Когда необходима генерация заголовочных файлов?**

Генерация заголовочных файлов необходима при импорте функций из плагинов, написанных на статически типизированных языках, таких как C++ или Go. Без этих заголовочных файлов компилятор не сможет ссылаться на экспортированные функции. Для динамически типизированных языков, таких как Python, генерация заголовочных файлов не требуется, поскольку связывание методов происходит во время выполнения.

## **Лучшие практики**

1. **Используйте инструмент-генератор**: Всегда используйте инструмент-генератор Plugify (онлайн или командной строки) для генерации заголовочных файлов для импортируемых функций.
2. **Подключайте сгенерированные заголовочные файлы**: Подключайте сгенерированные заголовочные файлы в исходные файлы вашего плагина для доступа к экспортированным функциям.
3. **Тестируйте тщательно**: Тестируйте импортированные функции, чтобы убедиться, что они работают так, как ожидается.
4. **Документируйте зависимости**: Четко документируйте плагины и функции, от которых зависит ваш плагин.

## **Заключение**

Импорт функций из другого плагина в Go прост, если вы используете скрипт `generator.py` для генерации необходимых заголовочных файлов. Эти заголовочные файлы предоставляют функции-обертки, которые обрабатывают поиск адреса функции и передачу параметров, что упрощает интеграцию функциональности из других плагинов. Следуя шагам и лучшим практикам, изложенным в этом руководстве, вы можете создавать надежные и совместимые плагины в экосистеме Plugify.