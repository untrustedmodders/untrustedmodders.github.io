---
title: Импорт функций
description: Узнайте, как импортировать функции из других плагинов, написанных на разных языках, и использовать их в своем собственном.
icon: lucide:arrow-down
---

В Plugify языковой модуль Lua позволяет вам импортировать и использовать функции из плагинов, написанных на других языках. Это достигается за счет **синтетических модулей, генерируемых во время выполнения**, которые обеспечивают бесшовное взаимодействие между плагинами.

Это руководство объясняет, как импортировать функции в Lua.

## Обзор

При импорте функций из другого плагина в Lua:

1. **Модули, генерируемые во время выполнения**: Plugify динамически генерирует синтетические модули во время выполнения, позволяя вам импортировать и вызывать функции из других плагинов напрямую.
2. **Прямые вызовы функций**: Функции вызываются напрямую с использованием импортированных синтетических модулей.

## Импорт функций в Lua

::steps
### Импорт синтетических модулей
Чтобы импортировать функции из другого плагина, используйте систему `require` от Plugify для загрузки синтетического модуля для целевого плагина.

::code-group
```lua [plugin.lua]
local Plugify = require('plugify')
local Vector2, Vector3, Vector4, Matrix4x4 = Plugify.Vector2, Plugify.Vector3, Plugify.Vector4, Plugify.Matrix4x4
local master = require('plugin_from_another_language')
```
::

- **`plugify`**: Основной модуль Plugify, предоставляющий служебные классы, такие как `Vector2`, `Vector3` и т.д.
- **`plugin_from_another_language`**: Синтетический модуль для целевого плагина. Замените это на имя плагина, из которого вы хотите импортировать функции.

### Вызов импортированных функций
После импорта синтетического модуля вы можете вызывать его функции напрямую.

#### Пример 1: Вызов простой функции
::code-group
```lua [plugin.lua]
local function func()
    master.ParamCallback(
        111, 
        2.2, 
        5.1234, 
        Vector4:new(-125.1, -225.2, -325.3, -425.4), 
        {60000000, -700000000, 80000000000}, 
        'D', 
        'pink metal', 
        'Y', 
        -100
    )
end

return {
    func = func
}
```
::

- **`ParamCallback`**: Это пример функции, экспортируемой целевым плагином. Замените его на фактическое имя функции.
- **Параметры**: Передайте необходимые параметры, как определено в сигнатуре функции.


::collapsible
#title
Показать манифест

#content
```json
 {
   "name": "ParamCallback",
   "funcName": "ParamCallback",
   "paramTypes": [
     {
       "name": "a",
       "type": "int32",
       "ref": false
     },
     {
       "name": "b",
       "type": "float",
       "ref": false
     },
     {
       "name": "c",
       "type": "double",
       "ref": false
     },
     {
       "name": "d",
       "type": "vec4",
       "ref": false
     },
     {
       "name": "e",
       "type": "int64[]",
       "ref": false
     },
     {
       "name": "f",
       "type": "char8",
       "ref": false
     },
     {
       "name": "g",
       "type": "string",
       "ref": false
     },
     {
       "name": "h",
       "type": "char16",
       "ref": false
     },
     {
       "name": "k",
       "type": "int16",
       "ref": false
     }
   ],
   "retType": {
     "type": "void"
   }
 }
```
::

#### Пример 2: Вызов функции с параметром-обратным вызовом
Если импортируемая функция требует обратный вызов в качестве параметра, вы можете определить обратный вызов в Lua и передать его функции. Вот пример:

::code-group
```lua [plugin.lua]
local CallbackHolder = {
    mockFunc = function(u32, v3, u_vec)
        -- Изменить параметры (переданные по ссылке)
        u32 = 42
        v3 = Vector3:new(1.0, 2.0, 3.0)
        u_vec = {1, 2, 3}
        -- Вернуть измененные значения
        return nil, u32, v3, u_vec
    end
}

local function func_call()
    local result = master.CallFuncCallback(CallbackHolder.mockFunc)
    return result
end

return {
    func_call = func_call
}
```
::

- **`CallFuncCallback`**: Это пример функции, которая принимает обратный вызов в качестве параметра.
- **`mockFunc`**: Это функция обратного вызова, определенная в JavaScript. Она изменяет параметры, переданные по ссылке, и возвращает их в массиве.
- **Возвращаемые значения**: Функция обратного вызова возвращает `null` (для типа возвращаемого значения void) и измененные параметры.

::collapsible
#title
Показать манифест

#content
```json
{
    "name": "CallFuncCallback",
    "funcName": "CallFuncCallback",
    "paramTypes": [
        {
            "name": "func",
            "type": "function",
            "ref": false,
            "prototype": {
                "name": "Func",
                "paramTypes": [
                {
                  "name": "u32",
                  "type": "uint32",
                  "ref": true
                },
                {
                  "name": "vec3",
                  "type": "vec3",
                  "ref": true
                },
                {
                  "name": "vecU32",
                  "type": "uint32[]",
                  "ref": true
                }
              ],
              "retType": {
                "type": "void"
              }
            }
        }
    ],
    "retType": {
        "type": "string"
    }
}
```
::

::

## Использование файлов типов для разработки

Хотя Lua является динамически типизированным языком и не использует файлы типов, как TypeScript, вы все равно можете воспользоваться такими средствами разработки, как автодополнение, документация и статический анализ, генерируя вспомогательные подсказки по типам или документацию для импортируемых API плагинов.

### Генерация файлов типов
Plugify предоставляет скрипт `generator.py` для автоматической генерации файлов типов для импортируемых плагинов.

::steps{level=4}
#### **Найдите скрипт генератора**:
- Скрипт `generator.py` находится в папке `generator` языкового модуля Lua.

:read-more{icon="lucide:link" to="https://github.com/untrustedmodders/plugify-module-lua/tree/main/generator" title="Репозиторий на GitHub"}

#### **Запустите скрипт генератора**:
- Откройте терминал или командную строку и перейдите в папку, содержащую `generator.js`.
- Запустите скрипт с помощью следующей команды:
  ```bash
  node generator.js "путь_к_плагину.pplugin" "выходная_папка"
  ```
    - **`путь_к_плагину.pplugin`**: Путь к файлу манифеста плагина (`.pplugin`), из которого вы хотите импортировать функции.
    - **`выходная_папка`**: Каталог, в котором будет сохранен сгенерированный файл типов.

**Пример**:
   ```bash
   python generator.py ./plugins/MyPlugin/MyPlugin.pplugin ./types/
   ```

#### **Сгенерированный файл типов**:
- Скрипт сгенерирует файл lua (например, `MyPlugin.lua`) в указанной выходной папке.
- Пример содержимого файла типов:
  ::code-group
  ```typescript [MyPlugin.lua]
  ---@param a integer
  ---@param b number
  ---@param c number
  ---@param d Vector4
  ---@param e integer[]
  ---@param f string
  ---@param g string
  ---@param h string
  ---@param k integer
  function ParamCallback(a, b, c, d, e, f, g, h, k) end
  
  ---@alias Func fun(u32: integer, vec3: Vector3, vecU32: integer[]): nil, integer, Vector3, integer[]
  
  ---@param callback Func
  ---@return string
  function CallFuncCallback(callback) end
  ```
  ::

#### **Использование файлов типов в вашей IDE**:
- Поместите сгенерированный файл типов (`.lua`) в каталог вашего проекта (но не в папку с плагинами).
- IDE, такие как VSCode, будут использовать файл типов для предоставления подсказок по типам и автодополнения.

**Поддержка VSCode**:
- VSCode автоматически обнаруживает файлы типов в вашем проекте. Убедитесь, что папка `types` (или папка, содержащая ваши `.lua` файлы) включена в ваш файл `luaconfig.json`.
- Пример конфигурации `luaconfig.json`:
  ```json
  {
      "compilerOptions": {
          "typeRoots": ["./types"]
      }
  }
  ```
::

## Примечания

- **Файлы типов необязательны**: Файлы типов предназначены только для разработки и не должны включаться в папку выполнения вашего плагина.
- **Эффективность во время выполнения**: Поскольку Lua является динамически типизированным, вызовы функций разрешаются во время выполнения без необходимости предварительно скомпилированных заголовков или определений типов.

Следуя этому руководству, вы можете легко импортировать и использовать функции из других плагинов в вашем плагине на Lua, используя при этом файлы типов для лучшего опыта разработки.