---
title: Создание языкового модуля
description: Руководство по расширению Plugify новыми языками.
icon: lucide:code
---

Это руководство проведет вас через процесс создания вашего первого языкового модуля для системы **Plugify**. Языковой модуль позволяет Plugify поддерживать плагины, написанные на определенном языке программирования. Следуя этому руководству, вы научитесь определять файл конфигурации, реализовывать необходимый интерфейс и интегрировать ваш модуль с ядром Plugify.

## **Быстрый старт**
::steps
### Клонируйте шаблонный проект:
   ```bash
   git clone https://github.com/untrustedmodders/template-lang-module.git
   ```
### Соберите проект:
   ```bash
   mkdir build && cd build
   cmake --preset Debug
   cmake --build .
   ```
### Реализуйте интерфейс `ILanguageModule`.
::

## **Введение**

Языковой модуль в Plugify - это динамическая библиотека, которая обеспечивает поддержку определенного языка программирования. Каждый языковой модуль должен включать файл конфигурации с именем `.pmodule`, который содержит метаданные и настройки, необходимые ядру Plugify для загрузки и управления модулем.

## **Манифест модуля**

Файл `.pmodule` - это файл конфигурации в формате JSON, который определяет основную информацию о вашем языковом модуле. Ниже приведен пример файла `.pmodule`:

::code-group
```json [*.pmodule]
{
    "version": "1.0.0",
    "name": "cpp_module",
    "language": "cpp",
    "description": "Добавляет поддержку плагинов на C++",
    "author": "untrustedmodders",
    "website": "https://github.com/untrustedmodders/",
    "license": "MIT",
    "platforms": []
}
```
::

### **Объяснение опций конфигурации**
- **`version`**: Семантическая версия языкового модуля.
- **`name`**: Удобное для пользователя имя языкового модуля.
- **`language`**: Язык программирования, поддерживаемый модулем (например, "cpp" для C++).
- **`description`**: Краткое описание функциональности модуля.
- **`author`**: Автор или организация, создавшая модуль.
- **`website`**: URL-адрес, ссылающийся на профиль или веб-сайт создателя.
- **`license`**: Лицензия модуля.
- **`platforms`**: Список платформ, поддерживаемых модулем (например, Windows, Linux).

## **Реализация интерфейса ILanguageModule**

Интерфейс `ILanguageModule` определяет методы, которые должен реализовать ваш языковой модуль. Ниже приведен обзор интерфейса:

::code-group
```c++ [plugin.cpp]
namespace plugify {
    class ILanguageModule {
    protected:
    ~ILanguageModule() = default;

    public:
        virtual Result<InitData> Initialize(const Provider& provider, const Extension& module) = 0;
        virtual void Shutdown() = 0;
        virtual void OnUpdate(DateTime dt) = 0;
        virtual Result<LoadData> OnPluginLoad(const Extension& plugin) = 0;
        virtual void OnPluginStart(const Extension& plugin) = 0;
        virtual void OnPluginUpdate(const Extension& plugin, DateTime dt) = 0;
        virtual void OnPluginEnd(const Extension& plugin) = 0;
        virtual void OnMethodExport(const Extension& plugin) = 0;
        virtual bool IsDebugBuild() = 0;
    };
}
```
::

### **Ключевые методы**
- **`Initialize`**: Вызывается при загрузке модуля. Используйте для настройки вашего модуля.
- **`Shutdown`**: Вызывается при выгрузке модуля. Используйте для очистки ресурсов.
- **`OnUpdate`**: Вызывается при обновлении модуля. Используйте для периодических обновлений.
- **`OnPluginLoad`**: Вызывается при загрузке плагина. Используйте для инициализации плагина.
- **`OnPluginStart`**: Вызывается при запуске плагина.
- **`OnPluginUpdate`**: Вызывается при обновлении плагина.
- **`OnPluginEnd`**: Вызывается при завершении работы плагина.
- **`OnMethodExport`**: Вызывается, когда плагин экспортирует методы для межплагинного взаимодействия.
- **`IsDebugBuild`**: Возвращает `true`, если модуль собран в режиме отладки.

## **Шаги по созданию вашего первого языкового модуля**

::steps
### **Настройте вашу среду разработки**
Убедитесь, что у вас установлены следующие инструменты:
- Текстовый редактор или IDE (например, Visual Studio, CLion).
- Совместимый компилятор C++ (например, MSVC, GCC, Clang).
- Установленный и настроенный фреймворк Plugify.

### **Используйте шаблонный проект**
Чтобы упростить процесс, клонируйте репозиторий **template-lang-module**:

```bash
git clone https://github.com/untrustedmodders/template-lang-module.git
```

### **Настройте и соберите шаблон**
1. Перейдите в каталог проекта:
   ```bash
   cd template-lang-module
   ```
2. Сгенерируйте файлы сборки:
   ```bash
   mkdir build && cd build
   cmake --preset Debug
   ```
3. Соберите проект:
   ```bash
   cmake --build .
   ```

### **Определите функциональность вашего модуля**
- Реализуйте интерфейс `ILanguageModule` в вашем модуле.
- Добавьте логику для загрузки, управления и выполнения плагинов на вашем целевом языке.
- Используйте библиотеку `plugify-function` для динамической генерации функций C, если это необходимо.

### **Реализуйте функциональность маршалинга (при необходимости)**
Для языков, требующих преобразования типов, реализуйте обертки для маршалинга, чтобы преобразовывать типы Plugify (например, `plg::vector`, `plg::string`) в нативные типы.

:read-more{icon="lucide:link" to="/developer-guides/runtime-marshalling"}

### **Создайте манифест модуля**
Файл `.pmodule` - это файл конфигурации в формате JSON, который определяет основную информацию о вашем языковом модуле. Шаблонный проект уже включает файл `.pmodule`, поэтому вам нужно только изменить его в соответствии с вашим модулем.

#### **Ключевые поля для обновления**
- **`language`**: Укажите язык программирования, который поддерживает ваш модуль (например, `cpp`, `python`, `javascript`).
- **`name`**: Укажите удобное для пользователя имя вашего модуля.
- **`description`**: Добавьте краткое описание функциональности вашего модуля.

#### **Пример файла манифеста**
Вот пример файла `.pmodule` для языкового модуля C++:

::code-group
```json [*.pmodule]
{
    "version": "1.0.0",
    "name": "cpp_module",
    "language": "cpp",
    "description": "Добавляет поддержку плагинов на C++",
    "author": "untrustedmodders",
    "website": "https://github.com/untrustedmodders/",
    "license": "MIT",
    "platforms": []
}
```
::

#### **Как изменить шаблон**
1. Откройте файл `.pmodule` в вашем шаблонном проекте.
2. Обновите поле `language`, чтобы указать язык программирования, который поддерживает ваш модуль.
3. Измените поля `name`, `description` и другие по мере необходимости.

#### **Структура файлов для ZIP-архива**
ZIP-архив для менеджера пакетов должен содержать следующие файлы в этой структуре:

::file-tree
---
tree:
   - bin:
      - template_language_module.dll
      - libtemplate_language_module.so
   - ^template_language_module.pplugin^
---
::

- **`bin/`**: Этот каталог должен содержать скомпилированные бинарные файлы вашего языкового модуля (например, `.dll` для Windows и `.so` для Linux).
- **`template_language_module.pplugin`**: Это файл манифеста плагина, который описывает ваш языковой модуль.

### **Протестируйте ваш модуль**
Чтобы правильно протестировать ваш языковой модуль, вам необходимо создать **cross_call_worker** и использовать его вместе с **cross_call_master** для проверки правильности маршалинга всех функций. Это гарантирует, что ваш модуль может обрабатывать межплагинное взаимодействие и обмен данными.

#### **Тестирование с межплагинным взаимодействием**
1. **Создайте cross_call_worker**: Реализуйте плагин, который экспортирует методы для вызова из `cross_call_master`. Этот плагин должен обрабатывать обмен данными и вызовы методов.
2. **Используйте cross_call_master**: `cross_call_master` будет вызывать методы из вашего `cross_call_worker` и проверять, что данные правильно маршалируются и обрабатываются.
3. **Проверьте пример на C++**: Для рабочего примера обратитесь к репозиторию `cpp-language-module`, который включает полностью реализованные `cross_call_worker` и `cross_call_master` для тестирования.

#### **Пример рабочего процесса**
1. `cross_call_master` вызывает метод из `cross_call_worker` для передачи строки.
2. `cross_call_worker` обрабатывает строку и вызывает метод обратно в `cross_call_master`, чтобы вернуть измененную строку.
3. Убедитесь, что строка была правильно передана и возвращена.

### **Опубликуйте ваш модуль**
Загрузите пакет вашего модуля на хостинг (например, GitHub Releases) и поделитесь им с сообществом Plugify. Чтобы упростить процесс выпуска, вы можете использовать **GitHub Actions** для автоматического создания релизов, генерации JSON-файлов репозитория и обработки сборок для конкретных платформ.

#### **Использование GitHub Actions для релизов**
Наша команда реализовала рабочие процессы GitHub Actions в существующих языковых модулях (например, `cpp-language-module`) для автоматизации процесса выпуска. Эти рабочие процессы могут служить хорошим примером для настройки вашего собственного автоматизированного конвейера выпуска.

##### **Ключевые особенности рабочего процесса**
1. **Автоматические релизы**:
   - При пуше нового тега (например, `1.0.0`) рабочий процесс автоматически создает релиз на GitHub.
   - Релиз включает скомпилированные файлы модуля и манифест `.pmodule`.

2. **Генерация JSON репозитория**:
   - Рабочий процесс генерирует JSON-файл репозитория (например, `repository.json`), который содержит метаданные о релизе.
   - Этот файл используется менеджером пакетов Plugify для проверки обновлений.

3. **Сборки для конкретных платформ**:
   - Рабочий процесс собирает модуль для нескольких платформ (например, Windows, Linux) и включает специфичные для платформы бинарные файлы в релиз.

4. **Проверка контрольных сумм**:
   - Рабочий процесс вычисляет контрольные суммы для артефактов релиза для обеспечения целостности файлов.

5. **Развертывание на GitHub Pages**:
   - JSON-файл репозитория развертывается на GitHub Pages, делая его доступным для менеджера пакетов Plugify.

6. **Уведомления в Discord**:
   - Рабочий процесс отправляет уведомление в канал Discord при публикации нового релиза.

##### **Пример рабочего процесса**
Вот пример рабочего процесса GitHub Actions для автоматизации релизов:

::collapsible
#title
Показать код

#content
```yaml

```
::

##### **Как использовать**
1. Скопируйте файл рабочего процесса (например, `.github/workflows/release.yml`) из одного из наших существующих языковых модулей (например, `cpp-language-module`).
2. Измените рабочий процесс в соответствии с процессом сборки и структурой файлов вашего модуля.
3. Отправьте файл рабочего процесса в ваш репозиторий и создайте новый тег (например, `1.0.0`), чтобы запустить процесс выпуска.

Используя GitHub Actions, вы можете автоматизировать процесс выпуска и гарантировать, что ваш модуль всегда будет актуальным и легко доступным для пользователей.

### **Поддерживайте и обновляйте ваш модуль**
- Обновляйте `version` и другие поля в вашем файле `.pmodule` для каждого релиза.
::

## **Рекомендации**
- **Минимизируйте зависимости**: Избегайте ненужных зависимостей для обеспечения совместимости и производительности.
- **Используйте отладочные сборки для тестирования**: Тестируйте ваш модуль в режиме отладки, чтобы выявлять проблемы на ранней стадии.
- **Документируйте ваш модуль**: Предоставляйте четкую документацию для пользователей и разработчиков.
- **Следуйте семантическому версионированию**: Используйте семантическое версионирование (например, `1.0.0`) для релизов вашего модуля.

## **Устранение неполадок**
- **Модуль не загружается**: Убедитесь, что файл `.pmodule` правильно отформатирован и размещен в правильном каталоге.
- **Плагины не инициализируются**: Проверьте логи на наличие ошибок и убедитесь, что ваш модуль реализует все необходимые методы.
- **Советы по отладке**: Используйте подробное логирование и отладчик для выявления и устранения проблем.