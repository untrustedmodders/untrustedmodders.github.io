[
{
	"uri": "//localhost:1313/en/metamod/compilation/",
	"title": "Compilation",
	"tags": [],
	"description": "",
	"content": "This guide will walk you through the compilation process of Metamod.\n"
},
{
	"uri": "//localhost:1313/en/general/",
	"title": "General",
	"tags": [],
	"description": "",
	"content": "Chapter 1 General This section will guide you through a Plugify installation.\nCurrently applicable for Source 2 Only.\n"
},
{
	"uri": "//localhost:1313/en/developing/started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": "If you would like to start developing server plugins with Plugify this is the right place for you!\nIn order to use Plugify you first need to install it on your game server. To do so, please follow the instructions described here.\nAs soon as you have successfully installed Plugify you can start writing your first plugin.\n"
},
{
	"uri": "//localhost:1313/en/general/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "This guide will walk you through the installation process for Plugify on your CS2 server. Plugify requires Metamod to be installed as a loader on the server. Follow the steps below to get everything set up.\nPrerequisites Install Metamod: Metamod (\u0026gt; 2.0) is required for loading Plugify. Follow the Metamod installation instructions here. Installation Steps Download Plugify: Download the latest version of CS2-Plugify from our download page here.\nExtract Plugify: Extract the downloaded archive into your server’s game folder. For example, if your server’s game folder is located at ../my_server/game/csgo, extract the files there.\nStart/Restart the Server: After extracting the files, start or restart your server to apply the changes.\nValidate the Installation: To ensure that Plugify has been installed correctly, open your server console and type meta list. If you are not working directly on your server, use rcon to access the console. The output should look something like this:\nmeta list Listing 1 plugin: [01] Plugify (1.0.0.0) by untrustedmodders Alternatively, you can verify the installation by using the plugify version command.\n"
},
{
	"uri": "//localhost:1313/en/metamod/compilation/linux/",
	"title": "Linux",
	"tags": [],
	"description": "",
	"content": "Linux Compilation A guide on how to compile Metamod:Source for Linux\nYou can use the Windows Subsystem for Linux (WSL) to compile on Windows. Tested on Ubuntu 20.04\nPrerequisites Git Python3 AMBuild File structure For the sake of simplicity we will be doing everything in an alliedmodders folder\nmkdir alliedmodders cd alliedmodders Ubuntu 20.04 setup sudo apt update sudo apt install python3-pip sudo apt-get install clang # make sure we can use pip installed packages anywhere echo \u0026#34;export PATH=\\\u0026#34;$HOME/.local/bin:$PATH\\\u0026#34;\u0026#34; \u0026gt;\u0026gt; ~/.bashrc . ~/.bashrc Download AMBuild git clone https://github.com/alliedmodders/ambuild pip install ./ambuild # In case of an error try # cd ambuild \u0026amp;\u0026amp; python setup.py install \u0026amp;\u0026amp; cd .. Instructions Double check you are still in the alliedmodders folder and run the following commands\nmkdir hl2sdk-root git clone https://github.com/alliedmodders/hl2sdk/ --branch cs2 hl2sdk-root/hl2sdk-cs2 git clone https://github.com/alliedmodders/metamod-source --recursive cd metamod-source echo \u0026#34;export HL2SDKCS2=/absolute/path/to/hl2sdk-root/hl2sdk-cs2\u0026#34; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#34;export MMSOURCE112=/absolute/path/to/metamod-source\u0026#34; \u0026gt;\u0026gt; ~/.bashrc . ~/.bashrc mkdir build \u0026amp;\u0026amp; cd build CC=clang CXX=clang++ python3 ../configure.py -s cs2 ambuild "
},
{
	"uri": "//localhost:1313/en/developing/started/first-plugin/",
	"title": "Writing your first plugin",
	"tags": [],
	"description": "",
	"content": "Creating your first plugin for the Plugify ecosystem is a straightforward process. This guide will walk you through the steps to create a plugin and the necessary configuration file, known as a .pplugin file.\nIntroduction Each plugin within the Plugify ecosystem should have an associated configuration file named .pplugin. This configuration file contains essential information that both the core and language modules use during the plugin loading process.\nThe .pplugin configuration file should be named exactly the same as the folder. The name of the plugin folder is allowed to contain alphanumeric characters (A-Z, a-z, and 0-9), special characters such as $, #, @, and hyphens (-), except spaces.\nAdditionally, each plugin should be located in separate folder inside the plugins directory.\nEach plugin folder should contain all the necessary files for the plugin, including the .pplugin configuration file and all binary files.\nplugins plugin_name1 bin plugin_name1.dll plugin_name1.so plugin_name1.pplugin This organized structure ensures clarity and ease of management for plugins within the Plugify ecosystem.\nplugins plugin_name1 bin plugin_name1.dll plugin_name1.so plugin_name1.pplugin plugin_name2 configs settings.txt bin plugin_name2.py plugin_name2.pplugin Example .pplugin File Below is an example of a .pplugin file:\n{ \u0026#34;fileVersion\u0026#34;: 1, \u0026#34;version\u0026#34;: 1, \u0026#34;versionName\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;friendlyName\u0026#34;: \u0026#34;Sample Plugin\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is a sample plugin.\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;untrustedmodders\u0026#34;, \u0026#34;createdByURL\u0026#34;: \u0026#34;https://github.com/untrustedmodders/\u0026#34;, \u0026#34;docsURL\u0026#34;: \u0026#34;https://github.com/untrustedmodders/sample_plugin\u0026#34;, \u0026#34;downloadURL\u0026#34;: \u0026#34;https://github.com/untrustedmodders/sample_plugin/releases/download/v1.0/sample_plugin.zip\u0026#34;, \u0026#34;updateURL\u0026#34;: \u0026#34;https://raw.githubusercontent.com/untrustedmodders/sample_plugin/main/sample_plugin.json\u0026#34;, \u0026#34;entryPoint\u0026#34;: \u0026#34;bin/sample_plugin\u0026#34;, \u0026#34;supportedPlatforms\u0026#34;: [], \u0026#34;languageModule\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;cpp\u0026#34; }, \u0026#34;dependencies\u0026#34;: [], \u0026#34;exportedMethods\u0026#34;: [] } Explanation of Configuration Options fileVersion: The version number of the configuration file format. version: The version number of the plugin. versionName: A human-readable version name, such as \u0026ldquo;1.0\u0026rdquo;. friendlyName: A user-friendly name for the plugin. description: A brief description or overview of the plugin. createdBy: The creator or author of the plugin. createdByURL: The URL linking to the creator\u0026rsquo;s profile or information. docsURL: The URL linking to the documentation for the plugin. downloadURL: The URL for downloading the plugin, typically a release package or ZIP file. updateURL: The URL for checking and fetching updates for the plugin. supportedPlatforms: An array listing the platforms supported by the plugin. (Currently empty in this example.) entryPoint: The entry point or main executable for the plugin, specified as \u0026ldquo;bin/sample_plugin\u0026rdquo;. (Depends on language module) languageModule: Information about the programming language module used. In this case, it\u0026rsquo;s specified as \u0026ldquo;cpp\u0026rdquo; (C++). dependencies: A list of plugin references specifying the dependencies required for the plugin. This field is crucial for topological sorting to load plugins in the correct order of initialization. exportedMethods: An array describing functions/methods exposed by the plugin. Integration with Core and Language Modules Upon loading a plugin, both the Plugify core and language modules use the information from the .pplugin configuration file. The core relies on the entry point and version to initiate and manage the plugin, while language modules may use additional parameters based on their specific requirements. Ensure that each plugin\u0026rsquo;s .pplugin file is accurately configured to guarantee a smooth integration process within the Plugify ecosystem.\nLanguage Module Restriction Each plugin should specify the programming language it is written in. The language parameter in the .pplugin file corresponds to the type of language module used by the plugin. It is important to note that multiple language modules with the same language are not allowed. This ensures a clear and unambiguous association between plugins and their respective language modules.\nDependency Management The information provided in the dependencies field is used for dependency management. The Plugify core utilizes Topological Sorting to determine the correct order for loading plugins based on their dependencies. This ensures that plugins with dependencies are initialized in the appropriate sequence, avoiding potential initialization issues.\nHere\u0026rsquo;s the representation of dependency in JSON format along with descriptions for each field:\n{ \u0026#34;name\u0026#34;: \u0026#34;dynohook\u0026#34;, \u0026#34;optional\u0026#34;: false, \u0026#34;supportedPlatforms\u0026#34;: [\u0026#34;windows\u0026#34;, \u0026#34;linux\u0026#34;], \u0026#34;requestedVersion\u0026#34;: 2 } name: The name of the plugin reference. This field identifies the dependency by its unique name within the Plugify ecosystem. optional: Indicates whether the plugin reference is optional. If set to true, the core system will consider the dependency as optional, and its absence won\u0026rsquo;t prevent the plugin from loading. If set to false, the dependency is mandatory for the plugin to function correctly. supportedPlatforms: Specifies the platforms supported by the plugin reference. This field helps ensure that the dependency is compatible with the current platform during initialization. requestedVersion: An optional field representing the requested version of the plugin reference. If provided, the core system will validate that dependency matches the specified version. If not provided, any compatible version may be used. Step-by-Step Guide to Creating Your First Plugin 1. Set Up Your Development Environment Ensure you have the necessary tools and libraries installed for developing a plugin. This typically includes:\nA text editor or IDE. The appropriate language compiler or interpreter (e.g., GCC for C++, Mono for C# plugins, ect.). The Plugify framework installed and configured. 2. Create the Plugin Source Code Write the source code for your plugin. This will depend on the language module specified in your .pplugin file. Each plugin source file is different and should be tailored to the specific language module for which it is created. For example, if you are writing a C++ plugin, you would create your source files accordingly, whereas a Python plugin would require Python scripts.\nc\u0026#43;\u0026#43;\rc#\rpython\rgo\r#include \u0026lt;plugify/cpp_plugin.h\u0026gt; #include \u0026lt;plugin_export.h\u0026gt; #include \u0026lt;iostream\u0026gt; class ExamplePlugin : public plugify::IPluginEntry { public: void OnPluginStart() override { std::cout \u0026lt;\u0026lt; \u0026#34;Example Start!\u0026#34; \u0026lt;\u0026lt; std::endl; } void OnPluginEnd() override { std::cout \u0026lt;\u0026lt; \u0026#34;Example End!\u0026#34; \u0026lt;\u0026lt; std::endl; } void MakePrint(int count, const std::string\u0026amp; message) { for (int i = 0; i \u0026lt; count; ++i) { std::cout \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } } } g_examplePlugin; EXPOSE_PLUGIN(PLUGIN_API, \u0026amp;g_examplePlugin) using System; using System.IO; using Plugify; namespace ExamplePlugin { public class SamplePlugin : Plugin { void OnStart() { Console.Write($\u0026#34;{Name}: OnStart\\n\u0026#34;); } void OnEnd() { Console.Write($\u0026#34;{Name}: OnEnd\\n\u0026#34;); } } } from plugify.plugin import Plugin, PluginInfo __plugin__ = PluginInfo(\u0026#39;ExamplePlugin\u0026#39;) class ExamplePlugin(Plugin): def plugin_start(self): print(\u0026#39;ExamplePlugin::plugin_start\u0026#39;) def plugin_end(self): print(\u0026#39;ExamplePlugin::plugin_end\u0026#39;) package main import ( \u0026#34;fmt\u0026#34; \u0026#34;plugify-plugin/plugify\u0026#34; ) func init() { plugify.OnPluginStart(func() { fmt.Println(\u0026#34;OnPluginStart\u0026#34;) }) plugify.OnPluginEnd(func() { fmt.Println(\u0026#34;OnPluginEnd\u0026#34;) }) } func main() {} Attachments\rcpp_example_plugin.zip\r(2 KB)\rcsharp_example_plugin.zip\r(29 KB)\rgo_example_plugin.zip\r(9 KB)\rpy_example_plugin.zip\r(852 B)\rEach plugin may require different process for compilation, it approximately look something like this:\nc\u0026#43;\u0026#43;\rc#\rpython\rgo\rmkdir build \u0026amp;\u0026amp; cd build cmake .. cmake --build . csc -target:library -out:ExamplePlugin.dll -reference:plugify/Plugify.dll ExamplePlugin.cs # Not need to build go build -buildmode=c-shared -o go_example_plugin.dll main.go 3. Create the .pplugin Configuration File Create a .pplugin file in the root directory of your plugin project. Use the example provided above as a template, and modify the values to suit your plugin.\n4. Specify the Entry Point Ensure the entryPoint field in your .pplugin file points to the main executable or script of your plugin. This is the entry point that Plugify will use to load your plugin. Each plugin\u0026rsquo;s entryPoint is different and should be tailored to the specific language module for which it is created.\n5. Define Dependencies List any dependencies your plugin requires in the dependencies field. This ensures that Plugify loads these dependencies before your plugin.\n6. Organize Your Plugin Directory Place your plugin binary and its .pplugin file in the appropriate directory. Each plugin should be located in separate folder inside plugins directory.\n7. Build and Package Your Plugin Compile your plugin if necessary (e.g., for C++/C# plugins). Package your plugin files and the .pplugin file into a ZIP archive or similar format specified in the downloadURL.\n8. Test Your Plugin Before publishing your plugin, test it thoroughly to ensure it works as expected. Check for any issues or missing dependencies.\n9. Publish Your Plugin Upload your plugin package to a hosting service (e.g., GitHub releases) and update the downloadURL in your .pplugin file accordingly. Share your plugin with the our community!\n10. Update Your Plugin Maintain and update your plugin as needed. Update the version, versionName, and other relevant fields in your .pplugin file for each new release. Ensure the updateURL points to the latest .json file for automatic updates.\nBy following these steps, you can create and share your first plugin within the Plugify ecosystem. Happy coding!\n"
},
{
	"uri": "//localhost:1313/en/developing/",
	"title": "Developing",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Developing This section will guide you through a developing process.\n"
},
{
	"uri": "//localhost:1313/en/metamod/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "A simple guide on how to install Metamod:Source on a Source2 dedicated server\nMetamod is a mod loader with basic plugin API. It will not provide any functionality on its own.\nSteps Download the latest dev build from the releases page Move the addons folder to your game/csgo folder Edit gameinfo.gi in game/csgo and add Game\tcsgo/addons/metamod to the SearchPaths section \u0026#34;GameInfo\u0026#34; { game \u0026#34;Counter-Strike 2\u0026#34; title \u0026#34;Counter-Strike 2\u0026#34; title_pw\t\u0026#34;E58F8DE68190E7B2BEE88BB1EFBC9AE585A8E79083E694BBE58ABF\u0026#34; LayeredOnMod\tcsgo_imported // Inherits the gameinfo.gi data from csgo_imported (which itself inherits from csgo_core) FileSystem { SearchPaths { Game_LowViolence\tcsgo_lv // Perfect World content override +\tGame\tcsgo/addons/metamod Game\tcsgo Game\tcsgo_imported Game\tcsgo_core Game\tcore ... Whenever CS2 updates you need to edit the gameinfo.gi file again as it is replaced with each update.\n"
},
{
	"uri": "//localhost:1313/en/general/updating/",
	"title": "Updating",
	"tags": [],
	"description": "",
	"content": "Manually Delete the entire ../addons/plugify/bin/ directory. Continue with the installation tutorial. Automatically Plugify seamlessly integrates with a package manager, a tool that automates the process of installing, upgrading, configuring, and removing packages (plugins and language modules) in a consistent manner. Each plugin and language module is considered a package, and the package manager simplifies the management of these components.\n"
},
{
	"uri": "//localhost:1313/en/metamod/compilation/windows/",
	"title": "Windows",
	"tags": [],
	"description": "",
	"content": "Windows Compilation A guide on how to compile Metamod:Source for Windows\nPrerequisites Git Python3 AMBuild Visual Studio 2022 Installing Visual Studio 2022 Download the community version installer and install the Desktop development with C++ component\nFile structure For the sake of simplicity we will be doing everything in an alliedmodders folder\nmkdir alliedmodders cd alliedmodders Download AMBuild git clone https://github.com/alliedmodders/ambuild pip install ./ambuild # In case of an error try # cd ambuild \u0026amp;\u0026amp; python setup.py install \u0026amp;\u0026amp; cd .. Instructions Double check you are still in the alliedmodders folder and run the following commands\nmkdir hl2sdk-root git clone https://github.com/alliedmodders/hl2sdk/ --branch cs2 hl2sdk-root/hl2sdk-cs2 git clone https://github.com/alliedmodders/metamod-source --recursive cd metamod-source setx HL2SDKCS2 C:/absolute/path/to/hl2sdk-root/hl2sdk-cs2 setx MMSOURCE112 C:/absolute/path/to/metamod-source mkdir build \u0026amp;\u0026amp; cd build python ../configure.py -s cs2 ambuild "
},
{
	"uri": "//localhost:1313/en/contributing/",
	"title": "Contributing",
	"tags": [],
	"description": "",
	"content": "Chapter 3 Contributing This section will guide you through a contributing suggestions.\n"
},
{
	"uri": "//localhost:1313/en/general/configuration/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": "Global plugify parameters Plugify lets you define the following parameters in your plugify.pconfig (here, values are default).\nNote that some of these parameters are explained in details in other sections of this documentation.\n{ // The base directory where Plugify will look for and manage its addons \u0026#34;baseDir\u0026#34;: \u0026#34;addons/plugify\u0026#34;, // The severity level for logging. Options typically include \u0026#34;debug\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;warn\u0026#34;, \u0026#34;error\u0026#34;, \u0026#34;fatal\u0026#34;, \u0026#34;verbose\u0026#34;. To disable use \u0026#34;none\u0026#34;. \u0026#34;logSeverity\u0026#34;: \u0026#34;debug\u0026#34;, // A list of repository URLs from which Plugify can fetch addon modules. // These repositories should provide JSON files with package definitions. \u0026#34;repositories\u0026#34;: [ \u0026#34;https://raw.githubusercontent.com/untrustedmodders/cpp-lang-module/main/cpp-lang-module.json\u0026#34;, \u0026#34;https://raw.githubusercontent.com/untrustedmodders/csharp-lang-module/main/csharp-lang-module.json\u0026#34;, \u0026#34;https://raw.githubusercontent.com/untrustedmodders/dynohook/main/dynohook.json\u0026#34;, \u0026#34;https://raw.githubusercontent.com/untrustedmodders/dyncall/main/dyncall.json\u0026#34;, \u0026#34;https://raw.githubusercontent.com/untrustedmodders/cs2-sdk-plugin/main/cs2sdk.json\u0026#34; ] } Explanation of Configuration Options: baseDir: This sets the base directory where Plugify will store and manage its addons. The path should be relative to the application\u0026rsquo;s root directory.\nlogSeverity: Defines the level of detail in the logs. The verbose level provides detailed logging, useful during development. Other levels include debug, info, warn, error and fatal which reduce the verbosity progressively. To disable use none.\nrepositories: This is a list of URLs pointing to JSON files that describe various addon modules. Plugify will fetch and use these modules. Each URL should point directly to a JSON file in a repository.\nBy adjusting these settings, you can customize how Plugify operates within your application, including where it stores addons, how much logging information it provides, and which repositories it fetches addons from.\n"
},
{
	"uri": "//localhost:1313/en/developing/started/exporing/",
	"title": "Exporting Functions",
	"tags": [],
	"description": "",
	"content": "In the Plugify ecosystem, functions can be exported to be accessible by other plugins. Typically, to export a function, it should be static in most cases. This approach ensures that the function can be called without instantiating an object, which simplifies integration and usage across different parts of the system. However, some language modules, such as C# or Python, offer more flexibility and allow you to export member functions of the main Plugin class. This means that in these languages, you can export functions that are part of a class instance, providing greater flexibility and enabling more complex interactions within your plugin. For languages that compile into dynamic link libraries (DLLs), such as C++ or C#, exported functions should be marked to be visible for exporting in the DLL. This is often achieved using specific compiler directives or attributes that indicate which functions should be accessible externally. Ensuring that functions are correctly marked for export is crucial for proper functionality within the Plugify framework. In most cases, language modules use native basic types that directly map to C types. However, language modules might have marshaling function wrappers to convert object types like std::vector or std::string to native language types. These wrappers facilitate the conversion and ensure seamless integration and interaction with the plugin system. When exporting functions, ensure that you follow the conventions and requirements of the specific language module you are using. Properly documented and accessible exported functions can significantly enhance the interoperability and functionality of your plugins within the Plugify ecosystem.\nThe use of the exporting function system is not the only way to enable communication between plugins. Some language modules, such as Python and C#, allow direct communication between plugins if they use the same language module. For example, C# plugins loaded by Mono into one domain can easily use each other\u0026rsquo;s data. You just need to compile plugins where you use other compiled binaries as references. This capability can significantly simplify interactions and data sharing between plugins written in the same language.\nBasic Type mapping The following lists how the types are exposed to the C++ API.\nType Alias Ref ? void void false bool bool true char char8 true char16_t char16 true int8_t int8 true int16_t int16 true int32_t int32 true int64_t int64 true uint8_t uint8 true uint16_t uint16 true uint32_t uint32 true uint64_t uint64 true uintptr_t ptr64 true uintptr_t ptr32 true float float true double double true void* function false std::string string true std::vector bool* true std::vector char8* true std::vector\u0026lt;char16_t\u0026gt; char16* true std::vector\u0026lt;int8_t\u0026gt; int8* true std::vector\u0026lt;int16_t\u0026gt; int16* true std::vector\u0026lt;int32_t\u0026gt; int32* true std::vector\u0026lt;int64_t\u0026gt; int64* true std::vector\u0026lt;uint8_t\u0026gt; uint8* true std::vector\u0026lt;uint16_t\u0026gt; uint16* true std::vector\u0026lt;uint32_t\u0026gt; uint32* true std::vector\u0026lt;uint64_t\u0026gt; uint64* true std::vector\u0026lt;uintptr_t\u0026gt; ptr64* true std::vector\u0026lt;uintptr_t\u0026gt; ptr32* true std::vector float* true std::vector double* true vector2 vec2 true vector3 vec3 true vector4 vec4 true matrix4x4 mat4x4 true Exported Functions Example 1 Function Name: Example_Function Exported Method Name: Example_Function_Exported_Name Parameters: Parameter 1: Type: ptr64 Name: param1 Parameter 2: Type: string Name: param2 Parameter 3: Type: int32 Name: param3 Parameter 4: Type: int8* Name: param4 Reference: true Return Type: string Here\u0026rsquo;s an example template that combines these elements:\n{ \u0026#34;name\u0026#34;: \u0026#34;Example_Function\u0026#34;, \u0026#34;funcName\u0026#34;: \u0026#34;Example_Function_Exported_Name\u0026#34;, \u0026#34;paramTypes\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;ptr64\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;param1\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;param2\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;int32\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;param3\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;int8*\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;param4\u0026#34;, \u0026#34;ref\u0026#34;: true } ], \u0026#34;retType\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } How it will look like on plugin\u0026rsquo;s side:\nc\u0026#43;\u0026#43;\rc#\rpython\rgo\rextern \u0026#34;C\u0026#34; PLUGIN_API void Example_Function(std::string\u0026amp; ret, void* p1, const std::string\u0026amp; p2, int32_t p3, std::vector\u0026lt;uint8_t\u0026gt;\u0026amp; p4) { // ... implementation std::construct_at\u0026lt;\u0026gt;(*ret, \u0026#34;Example_String\u0026#34;); } namespace CSharpTest { public class ExportClass { public static string Example_Function(UIntPtr p1, string p2, int p3, byte[] p4) { // ... implementation return \u0026#34;Example_String\u0026#34; } } } def Example_Function(p1, p2, p3, p4) # ... implementation return \u0026#34;Example_String\u0026#34; //export Example_Function func Example_Function(p1 uintptr, p2 string, p3 int32, p4 []int8) string { // ... implementation return \u0026#34;Example_String\u0026#34; } Example 2 Function Name: Example_Function Exported Method Name: Example_Function_Exported_Name Parameters: Parameter 1: Type: float Name: param1 Parameter 2: Type: double Name: param2 Reference: true Parameter 3: Type: function Name: param3 Return Type: void Here\u0026rsquo;s an example template that combines these elements:\n{ \u0026#34;name\u0026#34;: \u0026#34;Example_Function\u0026#34;, \u0026#34;funcName\u0026#34;: \u0026#34;Example_Function_Exported_Name\u0026#34;, \u0026#34;paramTypes\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;float\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;param1\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;double\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;param2\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;true\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;param3\u0026#34;, \u0026#34;prototype\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Example_Callback_Function\u0026#34;, \u0026#34;funcName\u0026#34;: \u0026#34;Example_Callback_Function_Exported_Name\u0026#34;, \u0026#34;paramTypes\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;ptr64\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;param1\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;param2\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;int32\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;param3\u0026#34; } ], \u0026#34;retType\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } ], \u0026#34;retType\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;void\u0026#34; } } How it will look like on plugin\u0026rsquo;s side:\nc\u0026#43;\u0026#43;\rc#\rpython\rgo\rusing Example_Callback_Function = std::string(*)(void*, const std::string\u0026amp;, int32_t); extern \u0026#34;C\u0026#34; PLUGIN_API void Example_Function(float p1, double\u0026amp; p2, Example_Callback_Function p4) { // ... implementation } namespace CSharpTest { public class ExportClass { delegate string Example_Callback_Function(UIntPtr p1, string p2, int p3); public static void Example_Function(float p1, ref double p2, Example_Callback_Function p4) { // ... implementation } } } def Example_Function(p1, p2, p3) # ... implementation return [None, p2] // ref parameter go to return tuple //export Example_Function func Example_Function(p1 float32, p2 *float64, p3 uintptr) string { // ... implementation // use \u0026#39;cgo\u0026#39; to call function pointer yourself } Example 3 Function Name: Example_Function Exported Method Name: Example_Function_Exported_Name Parameters: Parameter 1: Type: char8 Name: param1 Parameter 2: Type: double* Name: param2 Reference: true Parameter 3: Type: vec3 Name: param3 Return Type: string* Here\u0026rsquo;s an example template that combines these elements:\n{ \u0026#34;name\u0026#34;: \u0026#34;Example_Function\u0026#34;, \u0026#34;funcName\u0026#34;: \u0026#34;Example_Function_Exported_Name\u0026#34;, \u0026#34;paramTypes\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;char8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;param1\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;double*\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;param2\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;true\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;vec3\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;param3\u0026#34; } ], \u0026#34;retType\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string*\u0026#34; } } How it will look like on plugin\u0026rsquo;s side:\nc\u0026#43;\u0026#43;\rc#\rpython\rgo\rextern \u0026#34;C\u0026#34; PLUGIN_API void Example_Function(std::vector\u0026lt;std::string\u0026gt;\u0026amp; ret, char p1, const std::vector\u0026lt;double\u0026gt;\u0026amp; p2, const plugify::Vector3\u0026amp; p4) { // ... implementation std::construct_at\u0026lt;\u0026gt;(*ret, std::vector\u0026lt;std::string\u0026gt;{\u0026#34;Example_String1\u0026#34;, \u0026#34;Example_String2\u0026#34;, \u0026#34;Example_String3\u0026#34;}); } namespace CSharpTest { public class ExportClass { public static string[] Example_Function(char p1, double[] p2, Vector3 p4) { // ... implementation return string[]{\u0026#34;Example_String1\u0026#34;, \u0026#34;Example_String2\u0026#34;, \u0026#34;Example_String3\u0026#34;}; } } } def Example_Function(p1, p2, p3) # ... implementation ret = [\u0026#34;Example_String1\u0026#34;, \u0026#34;Example_String2\u0026#34;, \u0026#34;Example_String3\u0026#34;] return ret var globalString []string= []string{ \u0026#34;Example_String1\u0026#34;, \u0026#34;Example_String2\u0026#34;, \u0026#34;Example_String3\u0026#34;, } //export Example_Function func Example_Function(p1 int8, p2 []float64, p3 C.Vector3) []string { // ... implementation return globalString } Pointers For ref and out paramaters you\u0026rsquo;ll use the corresponding reference type. With setting \u0026ldquo;ref\u0026rdquo; parameter to true. So if you have a type listed as \u0026ldquo;int32\u0026rdquo;, you should use \u0026ldquo;int32_t\u0026amp;\u0026rdquo; in your implementation.\nArrays and Strings Arrays of any type must be described with a std::vector\u0026lt;\u0026gt;\u0026amp; and the strings should be pass by std::string\u0026amp;.\nReturn In x86-x64 calling conventions, which determine how function arguments are passed. For pod structures or objects returned by value, the caller must allocate memory for the return value and pass a pointer to it as the first argument.\n"
},
{
	"uri": "//localhost:1313/en/developing/started/importing/",
	"title": "Improting Functions",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/en/contributing/building/",
	"title": "Building",
	"tags": [],
	"description": "",
	"content": "On this page, you will learn how to build the Plugify binaries (plugify.so or plugify.dll) on your own. This allows you to run tests or contribute to the C++ side of Plugify by applying fixes, making improvements, or exposing useful features to the broader system.\nLinux To build Plugify on Linux, you need the following requirements:\nCMake 3.14 or later Git GCC 11.4 or later Once you have installed the requirements, follow these steps to build Plugify:\nClone the Plugify repository. Install CURL: sudo apt-get install -y libcurl4-openssl-dev. Navigate to the repository\u0026rsquo;s root directory. Create a build directory: mkdir build \u0026amp;\u0026amp; cd build. Configure the build using CMake presets: cmake --preset Release. Build the project: cmake --build .. By default, CMake uses all available CPU cores to speed up the build process. You can customize this by modifying the CMake presets.\nIf the build finishes successfully, it will say something like this: [100%] Built target plugify.\nThe compiled binaries are stored in build/Linux.\nWindows To build Plugify on Windows, you need the following requirements:\nCMake 3.14 or later Git Visual Studio 2022 or later Microsoft Build Tools (optional, to build directly via command line) Once you have installed the requirements, follow these steps to build Plugify:\nClone the Plugify repository. Navigate to the repository\u0026rsquo;s root directory. Open the CMakeLists.txt file located in the build directory. Switch the build mode to Release. Press F7 to start the build. If the build finishes successfully, it will say something like: ========== Build: 3 succeeded, 0 failed, 0 up-to-date, 1 skipped ==========.\nYou can also use the Microsoft Build Tools to build the project directly from the command line by running cmake --build ..\nThe compiled binaries are stored in build/Windows.\nMacOS To build Plugify on MacOS, you need the following requirements:\nCMake 3.14 or later Git Xcode Once you have installed the requirements, follow these steps to build Plugify:\nClone the Plugify repository. Install CURL: brew install curl. Navigate to the repository\u0026rsquo;s root directory. Create a build directory: mkdir build \u0026amp;\u0026amp; cd build. Configure the build using CMake presets: cmake --preset Release. Build the project: cmake --build .. By default, CMake uses all available CPU cores to speed up the build process. You can customize this by modifying the CMake presets.\nIf the build finishes successfully, it will say something like this: [100%] Built target plugify.\nThe compiled binaries are stored in build/MacOS.\nUsing CMake Presets CMake presets provide a convenient way to manage build configurations. A typical CMakePresets.json file might look like this:\n{ \u0026#34;version\u0026#34;: 3, \u0026#34;cmakeMinimumRequired\u0026#34;: { \u0026#34;major\u0026#34;: 3, \u0026#34;minor\u0026#34;: 14, \u0026#34;patch\u0026#34;: 0 }, \u0026#34;configurePresets\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;Default Config\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Default build using Ninja generator\u0026#34;, \u0026#34;generator\u0026#34;: \u0026#34;Ninja\u0026#34;, \u0026#34;binaryDir\u0026#34;: \u0026#34;${sourceDir}/build/${hostSystemName}/${presetName}\u0026#34;, \u0026#34;hidden\u0026#34;: true }, { \u0026#34;name\u0026#34;: \u0026#34;Debug\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;Debug\u0026#34;, \u0026#34;inherits\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;cacheVariables\u0026#34;: { \u0026#34;CMAKE_BUILD_TYPE\u0026#34;: \u0026#34;Debug\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;Release\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;Release\u0026#34;, \u0026#34;inherits\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;cacheVariables\u0026#34;: { \u0026#34;CMAKE_BUILD_TYPE\u0026#34;: \u0026#34;RelWithDebInfo\u0026#34; } } ], \u0026#34;buildPresets\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Debug\u0026#34;, \u0026#34;configurePreset\u0026#34;: \u0026#34;Debug\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Release\u0026#34;, \u0026#34;configurePreset\u0026#34;: \u0026#34;Release\u0026#34; } ] } "
},
{
	"uri": "//localhost:1313/en/general/commands/",
	"title": "Commands",
	"tags": [],
	"description": "",
	"content": "Plugin Manager Load plugin manager with plugins and language modules:\nplugify load Load plugin manager with plugins and language modules ignoring missing or conflict packages:\nplugify load --ignore Unload plugin manager:\nplugify unload Search for plugins Show information about a module:\nplugify plugin _plugin_name_ Show information about a plugin:\nplugify module _plugin_name_ List running modules:\nplugify modules List running plugins:\nplugify plugins Misc Show help:\nplugify help Version information:\nplugify version Package Manager Like other package managers, plugify can synchronize package lists with the software repositories to allow the user to download and install packages with a simple command by solving all required dependencies.\nInstall packages You can install a single package or multiple packages using plugify command in this fashion:\nplugify install _package_name1_ _package_name2_ ... To install a single package or multiple packages from file manifest:\nplugify install --file D:/_package_file_.json To install a single package or multiple packages from HTTP manifest:\nplugify install --link https://website.com/_package_file_.json To install missing packages to resolve all of current dependencies:\nplugify install --missing Update packages To update a single package or multiple packages:\nplugify update _package_name1_ _package_name2_ ... To update all installed packages:\nplugify update --all Remove an installed package To remove a single package or multiple packages, leaving all of its dependencies installed:\nplugify remove _package_name1_ _package_name2_ ... To remove all installed packages:\nplugify remove --all To remove a conflicted packages with unresolved dependencies:\nplugify remove --conflict Search for packages Print all local packages:\nplugify list Print all remote packages:\nplugify query You can search for remote packages by name:\nplugify search _package_name_ You can search for local packages by name:\nplugify show _package_name_ Manage packages You can snapshot installed packages into manifest file. File will be automatically generated at the base directory.\nplugify snapshot This command is essential for adding packages that are not in the default repositories. Developers create and maintain these repositories and allow others to add them via URLs. Since these are unofficial repositories, add them from trusted sources to avoid potential security threats.\nplugify repo https://website.com/_package_file_.json "
},
{
	"uri": "//localhost:1313/en/metamod/",
	"title": "Metamod",
	"tags": [],
	"description": "",
	"content": "Chapter 4 Metamod This section will guide you through a Metamod installation \u0026amp; compilation.\n"
},
{
	"uri": "//localhost:1313/en/general/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": "Project Leaders Nickname Full Name qubka Nikita Ushakov Kailo Maxim Telezhenko "
},
{
	"uri": "//localhost:1313/en/contributing/documentation/",
	"title": "Documentation",
	"tags": [],
	"description": "",
	"content": "There are several areas in Plugify where you can contribute, and we appreciate every contribution! To contribute to Plugify, please use GitHub\u0026rsquo;s pull request functionality. You can read more about pull requests on the GitHub help page.\nWhen creating a pull request, please always provide a reason for the changes you made. We will then review, discuss, and merge or close it.\nIf you successfully contribute to Plugify, we will gladly add you to our credits page (if you want).\nContributing to the Source Code If you want to contribute to the source code, you can simply create a pull request. But before creating a new pull request, please consider these two points:\nTest the changes you have made. Try to roughly meet our coding convention. We are recommeding use our Clang-Format and Clang-Tidy configs to automatically adjust style. Contributing to the Wiki Contributing to this wiki will also be done via pull requests. We are using Hugo to create the wiki. Therefore, you can find markdown files in Plugify\u0026rsquo;s documentation repository. Markdown files in that directory are usually simple wiki pages like this one.\nThe source code is documented using Doxygen. Doxygen configuration files are located in the docs directory. The documentation is mostly auto-generated, so these files only contain a few directives. For example:\n/** * @file * @brief Brief description of the file. */ /** * @brief Brief description of the function. * * Detailed description of the function. */ void exampleFunction(); The Doxygen directives tell the tool to parse the source code and look for Doxygen comments in the doc strings of the C++ objects (e.g., functions and classes). However, in some cases, you have to manually document specific things. In that case, you can simply extend or replace the Doxygen configuration file for the module you want to edit.\nBefore creating a pull request, you should also test if the HTML output of your change is correct and looks good. To do so, you can build an offline copy of the wiki. Building an offline copy is very simple.\ncd build cmake .. -DPLUGIFY_BUILD_DOCS=ON cmake --build . --target docs The API reference is created in HTML format in the build/docs/html directory. To navigate it with your favorite browser:\ncd build your_favorite_browser docs/html/index.html If we have merged your pull request, our CI/CD pipeline will be triggered and a new build will be created. As soon as the new build has been finished, it is used to update the wiki that gets published automatically. The whole process usually takes 10-15 minutes.\nIf you have made a change to the source code documentation directly in the source code, you have to regenerate the documentation using Doxygen.\nAlways regenerating the documentation and typing the long build command can get very annoying. But luckily, you can create aliases in your shell configuration file (e.g., .bashrc or .zshrc). Just add alias docbuild=\u0026lsquo;cd docs \u0026amp;\u0026amp; doxygen Doxyfile\u0026rsquo;. Then you only need to enter docbuild in your terminal to build the offline documentation.\n"
},
{
	"uri": "//localhost:1313/en/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Introduction This is a community driven documentation that aims to help people with the development of Plugify plugins.\n"
},
{
	"uri": "//localhost:1313/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/en/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": "Contributors Thanks to them for making Open Source Software a better place !\nAnd a special thanks to @vjeantet for his work on docdock, a fork of hugo-theme-learn. v2.0.0 of this theme is inspired by his work.\nPackages and libraries mermaid - generation of diagram and flowchart from text in a similar manner as markdown font awesome - the iconic font and CSS framework jQuery - The Write Less, Do More, JavaScript Library lunr - Lunr enables you to provide a great search experience without the need for external, server-side, search services\u0026hellip; horsey - Progressive and customizable autocomplete component clipboard.js - copy text to clipboard highlight.js - Javascript syntax highlighter modernizr - A JavaScript toolkit that allows web developers to use new CSS3 and HTML5 features while maintaining a fine level of control over browsers that don\u0026rsquo;t support Tooling Netlify - Continuous deployement and hosting of this documentation Hugo "
},
{
	"uri": "//localhost:1313/en/showcase/",
	"title": "Showcase",
	"tags": [],
	"description": "",
	"content": "TAT by OVH Tshark.dev by Ross Jacobs inteliver by Amir Lavasani "
},
{
	"uri": "//localhost:1313/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]